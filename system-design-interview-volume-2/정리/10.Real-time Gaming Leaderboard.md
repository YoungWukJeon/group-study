# 실시간 게임 순위표
이번 장에서는 모바일 게임의 리더보드, 즉 순위표를 설계한다.  
순위표란 특정 토너먼트나 경연에서 누가 선두를 달리고 있는지를 보여주기 위해 게임 등에서 흔히 사용되는 장치로, 사용자는 과제나 도전을 완료하며 포인트를 얻고 가장 많은 포인트를 획득한 사람이 순위표의 맨 위에 자리하는 구조이다.  
![10-1.png](images%2F10-1.png)  

## 1단계: 문제 이해 및 설계 범위 확정
순위표는 간단한 기능을 구현하지만 복잡성을 더할 수 있는 여러가지 문제가 있으므로 요구사항을 명확하게 정리한다.  
```text
지원자: 순위표의 점수는 어떻게 계산하나요 ?
면접관: 사용자는 경기에서 승리하면 포인트를 얻습니다. 이 포인트로 점수를 계산하면 됩니다. 사용자는 경기에서 이길때마다 1점의 포인트를 추가로 획득하게 됩니다.
지원자: 모든 플레이어가 순위표에 포함되어야 하나요?
면접관: 네
지원자: 한 순위표는 얼마 동안이나 유효한가요?
면접관: 매달 새로운 토너먼트를 시작할 때마다 새로운 순위표를 만듭니다.
지원자: 상위 10명의 사용자만 신경 써도 되나요?
면접관: 상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시할 수 있어야 합니다. 시간이 허락한다면 어떤 사용자보다 4순위 위 또는 아래에 있는 사용자들까지 반환하는 방법도 논의해 보죠.
지원자: 토너먼트에 참가하는 사용자는 몇 명인가요?
면접관: 평균 일간 활성 사용자 수(DAU) 500만 명, 월간 활성 사용자 수(MAU) 2,500만 명으로 가정하겠습니다.
지원자: 토너먼트 기간 동안 평균 몇 경기가 진행된아ㅛ?
면접관: 각 선수는 하루 평균 10경기를 치릅니다.
지원자: 두 플레이어의 점수가 같을 경우 어떻게 순위를 결정하나요?
면접관: 이 경우 두 사람의 순위는 동일합니다. 시간이 허락한다면 동점자 사이의 순위를 가르는 방법도 이야기해보도록 합시다.
지원자: 순위표가 실시간이어야 하나요?
면접관: 예, 실시간 또는 가능한 실시간에 가깝게 결과를 표시했으면 좋겠습니다. 누적된 결과 이력을 보여주는 것은 바람직하지 않습니다.
```

### 기능 요구사항
- 순위표에 상위 10명의 플레이어를 표시한다.
- 특정 사용자의 순위를 표시한다.
- 어떤 사용자보다 4순위 위와 아래에 있는 사용자를 표시한다. (보너스 문제)

### 비기능 요구사항
- 점수 업데이트는 실시간으로 순위표에 반영한다.
- 일반적인 확장성, 가용성 및 안정성 요구사항

### 개략적 규모 추정
- 게임을 하는 사용자가 24시간 동안 고르게 분포한다고 가정하면 DAU가 500만 명인 게임의 경우 초당 평균 50명의 사용자가 게임을 플레이하게 된다. (5,000,000 DAU / 10^5 sec =~ 50). 하지만 그렇게 사용량이 균등한 경우는 별로 없으며, 서로 다른 시간대의 사람들이 동시에 게임을 할 수 있는 북미 지역 기준 저녁 시간이 피크 시간대일 가능성이 높다.이를 고려하기 위해 최대 부하는 평균의 다섯 배라고 가정하며 최대 250명의 사용자를 감당할 수 있어야 한다.
- 사용자 점수 획득 QPS: 한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정하면, 점수를 획득하는 이벤트가 발생하는 QPS는 50 * 10 =~ 500 가량이며, 최대 QPS는 평균의 5배로 가정하였으므로 500 * 5 = 2,500이다.
- 상위 10명 순위표 가져오기 QPS: 각 사용자가 하루에 한 번 게임을 열고 상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시한다고 가정하면, QPS는 약 50이다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
### API 설계
#### POST /v1/scores
- 사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다. 이 API는 게임 서버에서만 호출할 수 있는 내부 API이며, 클라이언트는 이 API를 통하지 않고 순위표 점수를 직접 업데이트할 수 없다.  

|필드|설명|
|---|---|
|user_id|게임에서 승리한 사용자|
|points|사용자가 게임에서 승리하여 획득한 포인트 수|

응답:

|이름|설명|
|---|---|
|200 OK|사용자의 점수를 성공적으로 갱신한 경우|
|400 Bad Request|잘못된 인자가 전달되어 사용자 점수를 갱신할 수 없었던 경우|

#### GET /v1/scores
- 순위표에서 상위 10명의 플레이어를 가져온다.

응답 예제:
```json
{
  "data": [
    {
      "user_id": "user_id",
      "user_name": "alice",
      "rank": 1,
      "score": 976
    },
    {
      "user_id": "user_id",
      "user_name": "bob",
      "rank": 2,
      "score": 965
    }
  ],
  ...
  "total": 10
}
```

#### GET /v1/scores/{:user_id}
- 특정 사용자의 순위를 가져온다.

|필드|설명|
|---|---|
|user_id|순위 정보를 가져올 사용자 ID|

### 개략적 설계안
- 게임 서비스는 사용자가 게임을 플레이할 수 있도록 함
- 순위표 서비스는 순위표를 생성하고 표시하는 역할을 담당

![10-2.png](images%2F10-2.png)

1. 사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.
2. 게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.
3. 순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.
4. 해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
   - 상위 10명 순위표
   - 해당 사용자 순위표

최종적으로 해당 설계안을 사용하며, 어떤 대안이 무슨 이유로 선택되지 않았는지 알아보도록 하자.

#### 클라이언트가 순위표 서비스와 직접 통신해야 하나?
- 클라이언트가 점수를 정하는 방식
- 사용자가 프락시를 설치하고 점수를 마음대로 바꾸는 중간자 공격을 할 수 있기 때문에 보안상 안전하지 않다는 문제가 있어 점수는 서버가 설정해야 함
- 온라인 포커처럼 서버가 게임 전반을 통솔하는 경우 클라이언트가 점수를 설정하기 위해 게임 서버를 명시적으로 호출할 필요가 없을 수도 있음에 유의
- 게임 서버가 모든 게임 로직을 처리하고 게임이 언제 끝나는지 알기 때문에 클라이언트의 개입 없이도 점수를 정할 수 있음

![10-3.png](images%2F10-3.png)

#### 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?
- 게임 점수가 어떻게 사용되는지에 따라 크게 달라짐
- 해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면, 카프카에 데이터를 넣는 것이 합리적일 수 있음
- 특히 다른 플레이어에게 점수가 바뀌었음을 알려야 하는 순번제 게임이나 멀티플레이 게임의 경우 더욱 그러하며 해당 건에서는 요구사항에 포함되지 않아 포함하지 않음

![10-4.png](images%2F10-4.png)

#### 데이터 모델
데이터 모델은 순위표 저장소 시스템에서 핵심 구성 요소 중 하나이며, 관계형 데이터베이스, 레디스, NoSQL에 대해 고려할 수 있다.

##### 관계형 데이터 베이스
- 가장 간단한 방법
- 규모 확장성이 그다지 중요하지 않고 사용자 수가 많지 않은 경우
- 각 월별 순위표는 사용자 ID와 점수 열을 갖는 데이터베이스 테이블로 표현할 수 있다.
- 사용자가 경연에서 승리하면 신규 사용자에게는 1점을 주고, 기존 사용자에게는 원래 점수에 1을 더한다.
- 사용자의 순위를 결정 하려면 점수에 따라 테이블을 내림차순으로 정렬하면 된다.
- 실제 테이블이라면 game_id, timestamp 등의 추가 정보도 있지만 쉬운 설명을 위해 이번 달 순위표 데이터만 테이블에 저장한다고 가정한다.

순위표 DB 테이블  
![10-5.png](images%2F10-5.png)

사용자가 점수를 딴 경우    
![10-6.png](images%2F10-6.png)

점수는 1씩만 늘어난다고 가정하며, 해당 월의 순위표에 아직 해당 사용자의 레코드가 없다면 다음과 같이 새로운 레코드를 만들어 놓는다.  
```sql
INSERT INTO leaderboard (user_id, scores) VALUES ('mary1934', 1);
```
이미 레코드가 있는 사용자의 점수 갱신은 아래와 같다
```sql
UPDATE leaderboard set score=score + 1 where user_id='mary_1934';
```

특정 사용자 순위 검색  
![10-7.png](images%2F10-7.png)

- 사용자 순위를 가져오려면 순위표 테이블을 점수 기준으로 정렬한 다음 순위를 매긴다.

```sql
SELECT (@rownum := @rownum + 1) AS rank, user_id, score FROM leaderboard ORBER BY score DESC;
```

위의 질의에 대한 결과

|rank|user_id|score|
|---|---|---|
|1|happy_tomato|987|
|2|mallow|902|
|3|smith|870|
|4|mary1934|950|

관계형 데이터베이스를 사용하는 경우 데이터 많지 않을 때 효과적이지만 레코드가 수백만 정도로 많아지면 성능이 너무 나빠지는 문제 발생한다.  
이유는 아래와 같다.
- 사용자의 순위를 파악하려면 모든 플레이어를 순위표의 정확한 위치에 정렬해야 한다.
  - 같은 점수를 받은 사용자가 여럿일 수 있기 때문에 순위는 단순히 해당 목록 내의 사용자 위치라고 할 수 없다.
- SQL 데이터베이스는 지속적으로 변화하는 대략의 정보를 신속하게 처리하지 못한다.
  - 수백만 개 레코드에 순위를 매기려면 대략 수십 초 정도가 걸리므로, 실시간성을 요구하는 애플리케이션에는 적합하지 않다.
  - 데이터가 지속적으로 변경되기 때문에 캐시 도입도 불가능

위와 같은 이유로 관계형 데이터베이스는 본 시스템에 요구되는 다량의 읽기 부하를 처리하기 어려우며 일괄 작업으로 수행하면 RDS를 사용하는 것도 가능하겠지만, 일괄 처리 방식은 사용자에게 실시간 순위를 보여주어야 한다는 요구사항에 적합하지 않다.  
할 수 있는 한 가지 방안은 index를 추가하고 LIMIT 절을 사용하여 스캔할 페이지 수를 제한하는 것이며 아래와 같은 질의를 사용한다.  
```sql
SELECT (@rownum := @rownum + 1) AS rank, user_id, score
FROM leaderboard
ORDER BY score DESC
LIMIT 10
```

하지만 이 방식 역시 규모 확장성이 좋지 않은대
- 특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 하느모 성능이 떨어진다.
- 이 접근 방식으로는 순위표 상단에 있지 않은 사용자의 순위를 간단히 찾을 수 없다.


