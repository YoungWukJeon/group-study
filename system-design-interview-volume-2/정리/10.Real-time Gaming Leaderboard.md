# 실시간 게임 순위표
이번 장에서는 모바일 게임의 리더보드, 즉 순위표를 설계한다.  
순위표란 특정 토너먼트나 경연에서 누가 선두를 달리고 있는지를 보여주기 위해 게임 등에서 흔히 사용되는 장치로, 사용자는 과제나 도전을 완료하며 포인트를 얻고 가장 많은 포인트를 획득한 사람이 순위표의 맨 위에 자리하는 구조이다.  
![10-1.png](images%2F10-1.png)  

## 1단계: 문제 이해 및 설계 범위 확정
순위표는 간단한 기능을 구현하지만 복잡성을 더할 수 있는 여러가지 문제가 있으므로 요구사항을 명확하게 정리한다.  
```text
지원자: 순위표의 점수는 어떻게 계산하나요 ?
면접관: 사용자는 경기에서 승리하면 포인트를 얻습니다. 이 포인트로 점수를 계산하면 됩니다. 사용자는 경기에서 이길때마다 1점의 포인트를 추가로 획득하게 됩니다.
지원자: 모든 플레이어가 순위표에 포함되어야 하나요?
면접관: 네
지원자: 한 순위표는 얼마 동안이나 유효한가요?
면접관: 매달 새로운 토너먼트를 시작할 때마다 새로운 순위표를 만듭니다.
지원자: 상위 10명의 사용자만 신경 써도 되나요?
면접관: 상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시할 수 있어야 합니다. 시간이 허락한다면 어떤 사용자보다 4순위 위 또는 아래에 있는 사용자들까지 반환하는 방법도 논의해 보죠.
지원자: 토너먼트에 참가하는 사용자는 몇 명인가요?
면접관: 평균 일간 활성 사용자 수(DAU) 500만 명, 월간 활성 사용자 수(MAU) 2,500만 명으로 가정하겠습니다.
지원자: 토너먼트 기간 동안 평균 몇 경기가 진행된아ㅛ?
면접관: 각 선수는 하루 평균 10경기를 치릅니다.
지원자: 두 플레이어의 점수가 같을 경우 어떻게 순위를 결정하나요?
면접관: 이 경우 두 사람의 순위는 동일합니다. 시간이 허락한다면 동점자 사이의 순위를 가르는 방법도 이야기해보도록 합시다.
지원자: 순위표가 실시간이어야 하나요?
면접관: 예, 실시간 또는 가능한 실시간에 가깝게 결과를 표시했으면 좋겠습니다. 누적된 결과 이력을 보여주는 것은 바람직하지 않습니다.
```

### 기능 요구사항
- 순위표에 상위 10명의 플레이어를 표시한다.
- 특정 사용자의 순위를 표시한다.
- 어떤 사용자보다 4순위 위와 아래에 있는 사용자를 표시한다. (보너스 문제)

### 비기능 요구사항
- 점수 업데이트는 실시간으로 순위표에 반영한다.
- 일반적인 확장성, 가용성 및 안정성 요구사항

### 개략적 규모 추정
- 게임을 하는 사용자가 24시간 동안 고르게 분포한다고 가정하면 DAU가 500만 명인 게임의 경우 초당 평균 50명의 사용자가 게임을 플레이하게 된다. (5,000,000 DAU / 10^5 sec =~ 50). 하지만 그렇게 사용량이 균등한 경우는 별로 없으며, 서로 다른 시간대의 사람들이 동시에 게임을 할 수 있는 북미 지역 기준 저녁 시간이 피크 시간대일 가능성이 높다.이를 고려하기 위해 최대 부하는 평균의 다섯 배라고 가정하며 최대 250명의 사용자를 감당할 수 있어야 한다.
- 사용자 점수 획득 QPS: 한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정하면, 점수를 획득하는 이벤트가 발생하는 QPS는 50 * 10 =~ 500 가량이며, 최대 QPS는 평균의 5배로 가정하였으므로 500 * 5 = 2,500이다.
- 상위 10명 순위표 가져오기 QPS: 각 사용자가 하루에 한 번 게임을 열고 상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시한다고 가정하면, QPS는 약 50이다.

## 2단계: 개략적 설계안 제시 및 동의 구하기
### API 설계
#### POST /v1/scores
- 사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다. 이 API는 게임 서버에서만 호출할 수 있는 내부 API이며, 클라이언트는 이 API를 통하지 않고 순위표 점수를 직접 업데이트할 수 없다.  

|필드|설명|
|---|---|
|user_id|게임에서 승리한 사용자|
|points|사용자가 게임에서 승리하여 획득한 포인트 수|

응답:

|이름|설명|
|---|---|
|200 OK|사용자의 점수를 성공적으로 갱신한 경우|
|400 Bad Request|잘못된 인자가 전달되어 사용자 점수를 갱신할 수 없었던 경우|

#### GET /v1/scores
- 순위표에서 상위 10명의 플레이어를 가져온다.

응답 예제:
```json
{
  "data": [
    {
      "user_id": "user_id",
      "user_name": "alice",
      "rank": 1,
      "score": 976
    },
    {
      "user_id": "user_id",
      "user_name": "bob",
      "rank": 2,
      "score": 965
    }
  ],
  ...
  "total": 10
}
```

#### GET /v1/scores/{:user_id}
- 특정 사용자의 순위를 가져온다.

|필드|설명|
|---|---|
|user_id|순위 정보를 가져올 사용자 ID|

### 개략적 설계안
- 게임 서비스는 사용자가 게임을 플레이할 수 있도록 함
- 순위표 서비스는 순위표를 생성하고 표시하는 역할을 담당

![10-2.png](images%2F10-2.png)

1. 사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.
2. 게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.
3. 순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.
4. 해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
   - 상위 10명 순위표
   - 해당 사용자 순위표

최종적으로 해당 설계안을 사용하며, 어떤 대안이 무슨 이유로 선택되지 않았는지 알아보도록 하자.

#### 클라이언트가 순위표 서비스와 직접 통신해야 하나?
- 클라이언트가 점수를 정하는 방식
- 사용자가 프락시를 설치하고 점수를 마음대로 바꾸는 중간자 공격을 할 수 있기 때문에 보안상 안전하지 않다는 문제가 있어 점수는 서버가 설정해야 함
- 온라인 포커처럼 서버가 게임 전반을 통솔하는 경우 클라이언트가 점수를 설정하기 위해 게임 서버를 명시적으로 호출할 필요가 없을 수도 있음에 유의
- 게임 서버가 모든 게임 로직을 처리하고 게임이 언제 끝나는지 알기 때문에 클라이언트의 개입 없이도 점수를 정할 수 있음

![10-3.png](images%2F10-3.png)

#### 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?
- 게임 점수가 어떻게 사용되는지에 따라 크게 달라짐
- 해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면, 카프카에 데이터를 넣는 것이 합리적일 수 있음
- 특히 다른 플레이어에게 점수가 바뀌었음을 알려야 하는 순번제 게임이나 멀티플레이 게임의 경우 더욱 그러하며 해당 건에서는 요구사항에 포함되지 않아 포함하지 않음

![10-4.png](images%2F10-4.png)

#### 데이터 모델
데이터 모델은 순위표 저장소 시스템에서 핵심 구성 요소 중 하나이며, 관계형 데이터베이스, 레디스, NoSQL에 대해 고려할 수 있다.

##### 관계형 데이터 베이스
- 가장 간단한 방법
- 규모 확장성이 그다지 중요하지 않고 사용자 수가 많지 않은 경우
- 각 월별 순위표는 사용자 ID와 점수 열을 갖는 데이터베이스 테이블로 표현할 수 있다.
- 사용자가 경연에서 승리하면 신규 사용자에게는 1점을 주고, 기존 사용자에게는 원래 점수에 1을 더한다.
- 사용자의 순위를 결정 하려면 점수에 따라 테이블을 내림차순으로 정렬하면 된다.
- 실제 테이블이라면 game_id, timestamp 등의 추가 정보도 있지만 쉬운 설명을 위해 이번 달 순위표 데이터만 테이블에 저장한다고 가정한다.

순위표 DB 테이블  
![10-5.png](images%2F10-5.png)

사용자가 점수를 딴 경우    
![10-6.png](images%2F10-6.png)

점수는 1씩만 늘어난다고 가정하며, 해당 월의 순위표에 아직 해당 사용자의 레코드가 없다면 다음과 같이 새로운 레코드를 만들어 놓는다.  
```sql
INSERT INTO leaderboard (user_id, scores) VALUES ('mary1934', 1);
```
이미 레코드가 있는 사용자의 점수 갱신은 아래와 같다
```sql
UPDATE leaderboard set score=score + 1 where user_id='mary_1934';
```

특정 사용자 순위 검색  
![10-7.png](images%2F10-7.png)

- 사용자 순위를 가져오려면 순위표 테이블을 점수 기준으로 정렬한 다음 순위를 매긴다.

```sql
SELECT (@rownum := @rownum + 1) AS rank, user_id, score FROM leaderboard ORBER BY score DESC;
```

위의 질의에 대한 결과

|rank|user_id|score|
|---|---|---|
|1|happy_tomato|987|
|2|mallow|902|
|3|smith|870|
|4|mary1934|950|

관계형 데이터베이스를 사용하는 경우 데이터 많지 않을 때 효과적이지만 레코드가 수백만 정도로 많아지면 성능이 너무 나빠지는 문제 발생한다.  
이유는 아래와 같다.
- 사용자의 순위를 파악하려면 모든 플레이어를 순위표의 정확한 위치에 정렬해야 한다.
  - 같은 점수를 받은 사용자가 여럿일 수 있기 때문에 순위는 단순히 해당 목록 내의 사용자 위치라고 할 수 없다.
- SQL 데이터베이스는 지속적으로 변화하는 대략의 정보를 신속하게 처리하지 못한다.
  - 수백만 개 레코드에 순위를 매기려면 대략 수십 초 정도가 걸리므로, 실시간성을 요구하는 애플리케이션에는 적합하지 않다.
  - 데이터가 지속적으로 변경되기 때문에 캐시 도입도 불가능

위와 같은 이유로 관계형 데이터베이스는 본 시스템에 요구되는 다량의 읽기 부하를 처리하기 어려우며 일괄 작업으로 수행하면 RDS를 사용하는 것도 가능하겠지만, 일괄 처리 방식은 사용자에게 실시간 순위를 보여주어야 한다는 요구사항에 적합하지 않다.  
할 수 있는 한 가지 방안은 index를 추가하고 LIMIT 절을 사용하여 스캔할 페이지 수를 제한하는 것이며 아래와 같은 질의를 사용한다.  
```sql
SELECT (@rownum := @rownum + 1) AS rank, user_id, score
FROM leaderboard
ORDER BY score DESC
LIMIT 10
```

하지만 이 방식 역시 규모 확장성이 좋지 않은대
- 특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 하느모 성능이 떨어진다.
- 이 접근 방식으로는 순위표 상단에 있지 않은 사용자의 순위를 간단히 찾을 수 없다.

##### 레디스
수백만 명의 사용자에 대해서도 예측 가능한 성능을 제공하고 복잡한 DB 쿼리 없이도 일반적인 순위표 작업을 쉽게 수행할 방법은 없을까?
메모리 기반의 key-value 저장소인 레디스 사용할 수 있다. 메모리에서 동작하므로 빠른 읽기 및 쓰기가 가능하며, 순위표 시스템 설꼐 문제를 해결하는데 이상적인 정렬 집합(sorted set)라는 자료형을 제공한다.

###### 정렬 집합이란?
정렬 집합은 집합과 유사한 자료형, 정렬 집합에 저장된 각 원소는 점수에 연결되어 있으며, 집합 내 원소는 고유해야 하지만 같은 점수는 있을 수도 있다.  
점수는 정렬 집합 내 원소를 오름차순 정렬하는데 이용된다.  
정렬 집합은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료 구조를 사용하며, 각 역할은 아래와 같다.  
- 해시 테이블 : 사용자의 점수를 저장하기 위함
- 스킵 리스트 : 특정 점수를 딴 사용자들의 목록을 저장하기 위해 사용

사용자는 점수를 기준으로 정렬하며, 점수는 내림차순으로 정렬한다.
![10-8.png](images%2F10-8.png)  

정렬 집합에 대한 상세 구현은 설명하지 않으며, 개략적인 내용만 살펴보자.  
스킵 리스트는 빠른 검색을 가능하게 하는 자료구조로 정려ㅑㄹ된 연결 리스트에 다단계 색을 두는 구조이다.  
10-9와 같이 해당 자료 구조의 근간은 정렬된 단방향 연결 리스트이며, 삽입, 삭제, 검색 연산을 실행하는 시간 복자도는 O(n)이다.  
해당 연산이 더 빨리 실행되도록 하기 위해서는 ㅇ이진 검색 알고리즘처럼 중간 지점에 더 빨리 도달할 수 있도록 하는 것이며, 이를 위해 중간 노드를 하나씩 건너뛰는 1차 색인, 1차 색인 노드를 하나씩 건너뛰는 2차 색인을 추가할 수 있다.  
이를 통해 노드 사이의 거리가 n-1이 되면 더 이상의 색인은 추가하지 않으며, n은 총 노드의 수이다.  
![10-9.png](images%2F10-9.png)  

데이터 양이 적은 경우 스킵 리스트의 속도 개선 효과는 분명하지 않다. 데이터의 양이 많은 경우 기본 리스트만 있는 경우에는 찾는 노드에 도달하기 위해 62개의 노드를 거쳐야 하는 반면, 스킵 리스트의 경우 11개의 노드만 통과하면 된다.  
![10-10.png](images%2F10-10.png)  

정렬 집합은 삽입이나 갱신 연산을 할 때 모든 우너소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하더나 기존 원소를 검색하는 연산의 시간 복잡도가 O(log(n))이므로 관계형 데이터베이스보다 높은 성능을 낸다.  
반대로 관계형 데이터베이스에서 특정 사용자의 순위를 계산하려면 중첩 질의문을 실행해야 한다.  
```SQL
SELECT * (SELECT COUNT(*) FROM leaderboard lb2
WHERE lb2.score >= lb1.score) RANK
FROM leaderboard lb1
WHERE lb1.user_id = {:user_id};
```

###### 레디스 정렬 집합을 사용한 구현
정렬 집합을 이용하여 순위표를 구현할 때 사용할 레디스 연산을 알아보자.  
- ZADD : 기존에 없던 사용자를 집합에 삽입, 기존 사용자의 경우 점수를 업데이트 시간복잡도는 O(log(n))
- ZINCRBY : 사용자 점수를 지정된 값만큼 증가, 집합에 없는 사용자의 점수는 0에서 시작한다고 가정한다. 시간복잡도는 O(log(n))
- ZRANGE/ZREVRANGE : 점수에 따라 정렬된 사용자 중 특정 범위에 드는 사용자들을 가져온다. 순서, 항목 수, 시작 위치를 지정할 수 있으며, 시간복잡도는 O(log(n) + m) 여기서 m은 가져올 항목수 이고 n은 정렬 집합의 크기이다.
- ZRANK/ZREVRANK : 오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다. 시간복잡도는 O(log(n))

###### 정렬 집합을 사용한 구현의 동작 원리
1. 사용자가 점수를 획득한 경우
![10-11.png](images%2F10-11.png)  
매월 새로운 순위표를 위한 정렬 집합을 만들고 이전 순위표는 이력 데이터 저장소로 보내며, 사용자는 경연에서 승리하면 1점을 얻는다.  
ZINCRBY를 호출하여 순위표상의 사용자 점수를 1만큼 증가시키거나, 순위표에 없는 경우 순위표 집합에 추가한다.  
```text
ZINCRBY <키> <증분> <사용자>
# mary1934가 경연에서 승리한 경우
ex) ZINCRBY leaderboard_feb_2021 1 'mary1934'
```

2. 사용자가 순위표 상위 10명을 조회하는 경우
![10-12.png](images%2F10-12.png)  
가장 높은 점수를 받은 사용자부터 내림차순으로 정렬한 결과를 가져와야 하므로 ZREVRANGE를 호출한다. 사용자 목록뿐 아니라 각 사용자의 현재 점수도 가져와야 하므로 WITHSCORES 속성도 함께 전달한다.  
```text
ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES
```

3. 사용자가 자기 순위를 조회하는 경우
![10-13.png](images%2F10-13.png)  
ZREVRANK를 호출하면 특정 사용자의 순위를 가져올 수 있으며, 내림차순으로 정렬한 결과를 기준으로 순위를 매겨야 하므로 ZRANK는 사용하지 않는다.
```text
ZREVRANK leaderboard_feb_2021 'mart1934'
```

4. 특정 사용자 순위를 기준으로 일점 범위 내 사용자를 질의하는 경우
![10-14.png](images%2F10-14.png)  
명시적으로 주어진 요구사항은 아니지만, ZREVRANGE를 활용하면 특정한 사용자 전/후 순위 사용자 목록을 얻어낼 수 있다.
```text
# Mallow007의 rank가 361이고 전/후 순위 플레이어 4명씩 가지고오는 명령어
ZREVRANGE leaderboard_feb_2021 357 365
```

##### 저장소 요구사항
최소한 사용자 ID와 점수를 저장해야하며, 최악의 시나리오ㅡㄴ 우러간 활성 사용자 2,500만 명 모두가 최소 한 번 이상 게임에서 승리하는 바람에 모두 월 순위표에 올라야 하는 겨우.  
ID가 24자 문자열이고, 점수가 16비트 정수라고 한다면, 순위표 한 항목당 26바이트가 필요하며, MAU당 순위표 항목이 하나라는 최악의 시나리오를 가정하면 26바이트 * 2500만 = 6억 5,000만 바이트 또는 약 650 MB의 레디스 캐시가 필요하다.  
650MB의 메모리는 스킵 리스트 구현에 필요한 오버에드와 정렬 집합 해시를 고려해 메모리 사용량을 두 배로 늘린다고 해도 최신 레디스 서버 한 대만으로도 데이터를 충분히 저장할 수 있는 수치이다.  
CPU 및 I/O 사용량은 어떨까, 개략적 추정치에 따르면 갱신 연산은 최대 2500 QPS로 이 역시 단일 레디스 서버로 충분히 감당할 수 있는 부하이다.  
다만 데이터 영속성에 대해서는 고민할 필요가 있다. 레디스 노드에도 장애가 발생할 수 있기 때문이다. 다행히 레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 지원한다.  
그러나 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하려면 시간이 많이 걸린다. 그래서 보통은 레디스에 읽기 사본을 두는 식으로 구성하며, 주 서버에 장애가 생기면 읽기 사본을 승격시켜 주 서버로 만들고 새로운 읽기 사본을 만들어 연결하는 방식을 이용한다.  
MySQL과 같은 관계형 데이터베이스를 사용하는 경우에는 2개의 테이블이 필요하다. 사용자 테이블에는 사용자 ID와 사용자의 게임 내 이름을 저장하고. 점수 테이블에는 사용자 ID, 점수, 게임에서 승리한 시각을 저장한다.  이런 정보를 통해 경연 기록과 같은 다른 게임 기능 구현에 활용할 수 있으며, 인프라 장애 발생 시 레디스 순위표를 복구하는데 활용이 가능하다.  
마지막으로 성능 최적화를 위한 방안 중 하나로 자주 검색되는 상위 10명의 사용자 정보를 캐시하는 것을 고려할 수 있다.

## 3단계: 상세 설계
상세 설계 에서는 아래의 내용을 다룬다.
- 클라우드 서비스 사용 여부
  - 자체 서비스 이용
  - AWS 같은 클라우드 서비스 업체 이용
- 레디스의 규모 확장 문제
- NoSQL을 대안으로 사용하는 방안
- 기타 고려 사항

### 클라우드 서비스 사용 여부
#### 자체 서비스를 이용하는 방안
이 방식에서ㅡㄴ 매월 정렬 집합을 생성하여 해당 기간의 순위표를 저장하는 것을 가정하며, 해당 집합에는 사용자 및 점수 정보를 저장한다.  
이름 및 프로필 이미지와 같은 사용자 세부 정보는 MySQL 데이터베이스에 저장하며, 순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장하고, 순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장된 사용자 이름과 프로필 이미지도 가져온다.  
이 작업이 장기적으로 너무 비효율적이면 상위 사용자 10명의 세부 정보를 저장하는 프로필 캐시를 두어 해결할 수 있다.  
![10-15.png](images%2F10-15.png)

#### 클라우드 서비스를 이용하는 방안
이 방식에서는 기존 인프라가 AWS에 있어 클라우드로 순위표를 구축하는 것이 자연스러운 상황이라고 가정한다.  
아마존 API 게이트웨이와 AWS 람다의 두 가지 기술을 사용하며, API 게이트웨이를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결할 수 있다.  

| API                       |람다 함수|
|---------------------------|---|
| GET /v1/scores            |LeaderboardFetchTop10|
| GET /v1/scores/{:user_id} |LeaderboardFetchPlayerRank|
| POST /v1/scores           |LeaderboardUpdateScore|

AWS 람다는 가장 인기 있는 서버리스 컴퓨팅 플랫폼 중 하나로 서버를 직접 준비하거나 관리할 필요 없이 코드를 실행할 수 있으며, 필요할 대만 실행되어 트래픽에 따라 그 규모가 자동을 확장된다.  
서버리스는 클라우드에서 가장 인기 있는 형태로 모든 주요 클라우드 서비스에서 제공한다.  
개략적으로 설명하자면 게임 -> API 게이트웨이 -> 람다 -> 스토리지 를 통해 얻은 결과를 API 게이트웨이에 반환하고 API 게이트웨이는 그 결과를 애플리케이션에 전달한다.  
![10-16-17.png](images%2F10-16-17.png)  

### 레디스 규모 확장
앞서 500만 DAU를 가정하였고 이 수준이라면 한 대의 레디스 캐시 서버로 충분히 지원이 가능하다고 했다.  
그러나 여기서는 원래 규모의 100배인 5억 DAU를 처리해야 한다고 가정해보자. 최악의 경우 저장 용량은 65GB, 250,000 QPS의 질의를 처리할 수 있어야 하며, 이 정도 규모를 감당하려면 샤딩이 필요하다.  

#### 데이터 샤딩 방안
고정 파티션과 해시 파티션 두 가지 방식에 대해 알아보자.  

##### 고정 파티션
순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안 한 달 동안 획득할 수 있는 점수 범위가 1 ~ 1000이라고 가정하면, 그 데이터를 범위별로 나누어 샤드를 분리하는 방안
![10-18.png](images%2F10-18.png)

이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야 하는데, 그렇지 않으면 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야한다.  
해당 설계안에서는 애플리케이션이 샤딩 처리 주체가 된다고 가정한다. 각 기능별 동작 방식에 대해 알아보자.
먼저 입력 및 갱신에 대해 알아보자. 해당 사용자가 어느 샤드에 있는지 알아야 한다. MySQL 질의를 통해 사용자의 현재 점수를 계산하여 알아내는 것도 한가지 방법이지만, 사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 통해 알아내면 성능을 더 높일 ㅅ ㅜ있다.  
사용자의 점수에 따라 다른 샤드로 이동할 때 기존 샤드에서 해당 사용자를 제거한 다음 새 샤드로 옮겨야 한다는 것도 유의해야 한다.  
순위표에서 상위 10명의 플레이어를 가져오려면, 가장 높은 점수가 저장되는 샤드에서 상위 10명을 가지고 오는 간단한 연산을 진행하면 된다.  
특정 사용자의 순위를 알려면 해당 사용자가 속한 샤드 내 순위뿐 아니라 해당 샤드보다 높은 점수를 커버하는 모든 사용자 수를 알아야 한다. 특정 샤드에 속한 모든 사용자 수는 info keyspace 명령을 실행하면 시간복잡도는 O(1)이 된다.  

##### 해시 파티션
두 번째는 레디스 클러스터를 사용하는 것으로 사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우에 효과적이다. 레디스 클러스터는 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공하는데, 안정 해시는 사용하지 않지만 각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다.  
이 방식에는 총 16384개의 해시 슬롯이 있으며, CRC16(key) % 16384의 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다. 이로 인해 모든 키를 재분배 하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.
![10-19.png](images%2F10-19.png)  

해당 설계안에서의 각 기능별 동작을 알아보자.  
- 점수 갱신 : 해당 사용자의 샤드를 찾아(CRC16(key) % 16384로 찾을 수 있음) 변경
- 상위 10명의 플레이어 : 모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집 접근법 사용
  - 해당 방식은 모든 샤드에 접근해야하기 때문에 많은 지연 시간이 발생할 수 있는데 모든 샤드에 사용자를 질의하는 절차를 병렬화하여 지연 시간을 줄일 수 있다.
![10-20.png](images%2F10-20.png)
    
다만 이 방식에는 몇 가지 문제가 있다.
- 상위 k개의 결과를 반환해야 하는 경우, 각 샤드에서 많은 데이터를 읽고 정렬해야하므로 지연시간이 늘어남
- 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있어 많은 지연 시간 발생
- 특정 사용자의 순위를 결정할 간단한 방법이 없음

따라서 본 설계안에서는 고정 파티션 방식을 사용한다.  

##### 레디스 노드 크기 조정
레디스 노드의 크기 조정시 고려 사항
- 쓰기 작업이 많은 애플리케이션에는 많은 메모리 필요 
  - 장애에 대비해 스냅숏을 생성할 때 필요한 모든 쓰기 연산을 감당할 수 있어야 함
  - 쓰기 연산이 많은 애플리케이션에는 메모리를 두 배 할당하는 것이 더 안전

레디스는 성능 벤치마킹을 위해 redis-benchmark 라는 도구를 제공하는데 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 시뮬레이션하여 주어진 하드웨어로 초당 얼마나 많은 요청을 처리할 수 있는지 측정할 수 있다.  

#### 대안: NoSQL
레디스의 대안이 될 수 있는 솔루션으로는 NoSQL이 있다. 아래의 조건을 만족하는 것이 이상적이다.
- 쓰기 연산에 최적화 되어 있다.
- 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.

위의 조건을 만족하는 좋은 후보로 아마존의 DynamoDB, 카산드라, MongoDB 등이 있으며, 이 장에서는 DynamoDB를 예로 든다.  
DynamoDB는 안정적인 성능과 뛰어난 확장성을 제공하는 완전 관리형 NoSQL DB이며, 기본 키 이외의 속성을 활용하여 데이터를 효과적으로 질의할 수 있도록 전역 보조 색인을 제공한다.  
전역 보조 색인은 부모 테이블의 속성들로 구성되지만 기본 키는 부모 테이블과 다르다.  
![10-21.png](images%2F10-21.png)  

체스 게임의 순위표를 설계한다고 가정해보자.  
순위표와 사용자 테이블을 비정규화한 것으로, 순위표를 화면에 표시하는데 필요한 정보를 담고 있다.  
![10-22.png](images%2F10-22.png)  

그러나 이 방안은 규모 확장이 어렵고 레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야 하므로 사용자가 많아지면 성능이 떨어진다.  
game_name#{year-month}을 파티션 키로 점수를 정렬 키로 사용하면 테이블 전체를 읽어야 하는 일을 피할 수 있다.  
![10-23.png](images%2F10-23.png)  

이 방법은 부하가 높을 때 문제인데, DynamoDB는 안정 해시를 사용하여 여러 노드에 데이터를 분산하고, 각 항목은 파티션 키에 따라 선정된 노드에 저장된다.  
우리가 원하는 것은 데이터를 여러 파티션에 고르게 분산하는 것인데, 위의 그림과 같이 테이블을 설계하면 가장 최근 한 달치 데이터가 동일한 파티션에 저장될 뿐 아니라 핫 파티션이 되어 문제가 발생할 수 있다.  
한 가지 방법은 데이터를 n개 파티션으로 분할하고 파티션 번호 (user_id % number_of_partitions)를 파티션 키에 추가하는 것이다. 이를 쓰기 샤딩이라고 하는 패턴이다. 하지만 해당 방법은 읽기 및 쓰기 작업 모두를 복잡하게 만드므로, 장단점을 꼼꼼히 따져야 한다.  

두번째는 얼마나 많은 파티션을 두어야 하는 것이다. 쓰기 봄륨 또는 DAU를 기준으로 결정할 수 있으며, 파티션이 받는 부하와 읽기 복잡도 사이에는 타협적인 부분이 있음에 주의하자.  
같은 달 데이터를 여러 파티션에 고르게 분산시키면 한 파티션이 받는 부하는 낮아지지만 특정한 달의 데이터를 읽으려면 모든 파티션을 질의한 결과를 합쳐햐 하므로 구현 난이도는 높아진다.  
결과적으로 파티션을 수정한 테이블은 아래와 같다.  
![10-24.png](images%2F10-24.png)  

전역 보조 색인은 game_name#{year-month}#p{partition_number}를 파티션 키로 점수를 정렬 키로 사용하게 구성한다.  
그 결과 같은 파티션 내 데이터는 전부 점수 기준으로 정렬된 n개의 파티션이 만들어지며, 3개의 파티션이 있다고 했을 때 상위 10명의 사용자를 가져오려면 앞서 언급한 분산-수집 접근법을 사용한다. 
![10-25.png](images%2F10-25.png)  

파티션 수는 신중한 벤치마킹이 필요하며, 파티션이 많으면 각 파티션의 부하는 줄지만 최종 순위표를 만들기 위해 읽어야 하는 파티션은 더 많으므로 복잡성이 증가한다.  
그러나 앞서 레디스 파티션 기법과 마찬가지로 해당 접근법으로는 사용자의 상대적 순위를 쉽게 정할 수 없다. 하지만 사용자 위치의 백분위수를 구하는 것은 가능하며, 그것도 충분히 괜찮은 방법일 수 있다.
정확한 순위를 표시하는 것 보다 상위 10~20%에 속한다고 말하는 것이 나을 수 있다는 것이다.  
규모가 충분히 커 샤딩이 필요한 상황이라면 모든 샤드의 점수 분포는 거의 같다고 가정할 수 있는데, 이 가정 내에서 각 샤드의 점수 분포를 분석한 결과를 캐시하는 크론 작업을 만들 수 있다.
10번째 백분위 수 = 점수 < 100
20번째 백분위 수 = 점수 < 500
...
90번째 백분위 수 = 점수 < 6500

## 4단계: 마무리
추가로 고려해볼 수 있는 부분
### 더 빠른 조회 및 동점자 순위 판정 방안
레디스 해시를 사용하여 문자열 필드와 값 사이의 대응 관계를 저장
1. 순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응 관계를 저장하여 데이터베이스에 질의하지 않아도 빠르게 사용자 정보를 확인 가능
2. 두 사용자의 점수가 같은 경우 누가 먼저 점수를 받았는지에 따라 순위를 매길 수 있음. 사용자 ID와 해당 사용자가 마지막으로 승리한 경기의 타임스탬프 사이의 대응 관계를 저장

### 시스템 장애 복구
- 레디스 클러스터에서도 대규모 장애가 발생할 가능성이 있음
- 사용자가 게임에서 이길 때마다 MySQL 데이터베이스에 타임스탬프와 함께 그 사실을 기록한다는 사실을 활용하는 스크립트를 만들어 복구 하는 방안
- 사용자별로 모든 레코드를 훑으면서, 레코드당 한 번씩 ZINCRBY를 호출

