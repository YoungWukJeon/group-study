# 지표 모니터링 및 경보 시스템
지메일, 아웃룩, 야후 메일과 같은 대규모 이메일 서비스를 설계한다.  
인터넷의 성장으로 이메일의 양은 폭발적으로 증가하고 있으며, 2020년 기준 지메일의 활성 사용자는 18억명 이상, 아웃룩은 4억 명 이상의 사용자를 보유하고 있다.
![8-1.png](images%2F8-1.png)

## 1단계: 문제 이해 및 설계 범위 확정
- 오랜 세월동안 이메일 서비스는 복잡성과 규모 면에서 크게 달라졌으며, 현대적인 이메일 서비스는 다양한 기능을 갖춘 복잡한 시스템
- 모든 내용에 대해 설계할 수 없으므로, 질문을 통해 범위를 좁힐 필요가 있음
```text
지원자: 얼마나 많은 사람들이 사용하는 제품입니까?
면접관: 10억명 입니다.
지원자: 다음 기능이 중요할 것 같은대요.
  - 인증
  - 이메일 발송/수신
  - 모든 이메일 가져오기
  - 읽음 여부에 따른 이메일 필터링
  - 제목, 발신인, 메일 내용에 따른 검색 기능
  - 스팸 및 바이러스 방지 기능
면접관: 좋습니다. 하지만 인증은 건너뛰기로 하죠. 나머지 기능에만 집중합시다.
지원자: 사용자는 메일 서버에 어떻게 연결하나요?
면접관: 전통적으로는 SMTP, POP, IMAP 등의 프로토콜과 서비스 제공자 전용 프로토콜을 사용해 접속합니다. 이런 프로토콜은 구식(legacy)이라 볼 수 있겠습니다만 여전히 많이 사용되고 있습니다. 이번 면접에서는 HTTP를 사용한다고 가정하도록 하죠.
지원자: 첨부 파일도 지원해야 하나요?
면접관: 그렇습니다.
```

### 비기능 요구사항
- 안정성: 이메일 데이터는 소실되어서는 안 된다.
- 가용성: 이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야 한다. 아룰러 부분적으로 장애가 발생해도 시스템은 계속 동작해야 한다.
- 확장성: 사용자 수가 늘어나도 감당할 수 있어야 한다. 사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 한다.
- 유연성과 확장성: 새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있는 유연하고 확장성 높은 시스템이어야 한다. POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적이다. 따라서 유연성과 확장성을 갖추려면 맞춤형 프로토콜이 필요할 수도 있다.

### 개략적인 규모 추정
- 10억 명의 사용자
- 한 사람이 하루에 보내는 평균 이메일 수는 10건 이라고 가정하여 이메일 전송 QPS = 10^9 * 10 / 10^5 = 100,000
- 한 사람이 하루에 수신하는 이메일 수는 평균 40건이라고 가정하고, 이메일 하나의 메타데이터는 평균 50KB로 가정, 메타데이터는 주어진 이메일에 대한 모든 정보이며, 첨부 파일은 포함하지 않는다.
- 메타데이터는 DB에 저장한다고 가정한다.1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 10억 명 사용자 * 하루 40건의 이메일 * 365일 * 50KB =730PB
- 첨부 파일을 포함하는 이메일의 비율은 20%이며, 첨부 파일의 평균 크기는 500KB라고 가정
- 1년간 첨부파일을 보관하는데 필요한 저장 용량은 10억 명 사용자 * 하루 40개의 이메일 * 365일 * 20% * 500KB = 1,460PB
많은 데이터를 처리해야하기에 분산 DB 솔루션 필요
  
## 2단계: 개략적 설계안 제시 및 동의 구하기
이메일 서비스의 시간적인 흐름에 따른 변화와 각 시스템의 개략적인 설계안에 대해 알아보자

### 이메일 101
- 이메일을 주고받는 프로토콜에는 여러가지가 있는데, 대 부분은 POP, IMAP, SMTP같은 프로토콜을 사용해 왔다.

#### 이메일 프로토콜
- SMTP(Simple Mail Transfer Protocol)의 줄임말로 이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜
- POP(Post Office Protocol) : 이메일을 가져오는 목적으로 가장 널리 사용되는 프로토콜, 이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜, 단말로 다운로드된 이메일은 서버에서 삭제되며, 결괒거으로 한 대 단말에서만 이메일을 읽을 수 있다. 이 프로토콜을 사용하는 경우 클라이언트는 이메일을 일부만 읽을 수 없으며, 이메일을 확인하려면 전부 내려받아야 하기에 용량이 큰 첨부파일이 붙은 이메일을 읽으려면 시간이 오래 걸린다.
- IMAP: 이메이 클라이언트가 원격 메일 서버에서 이메일을 수신하는데 사용되는 또 다른 표준 프로토콜, POP와 달리 클릭하지 않으면, 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않는다. 따라서 여러 단말에서 이메일을 읽을 수 있어 개인 이메일 계정에서 가장 널리 사용되는 프로토콜이다. 이메일을 실제로 열기 전에는 헤더만 다운로드 하여 인터넷 속도가 느린 환경에서도 잘 동작한다.
- HTTPS: HTTPS는 기술적으로 보자면 메일 전송 프로토콜은 아니다. 하지만 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있다. MS의 아웃룩은 ActiveSync라는 HTTPS 기반 자체 프로토콜을 통해 모바일 단말과의 통신을 처리한다.

#### 도메인 이름 서비스(DNS)
- DNS 서버는 ㅇ수신자 도메인의 메일 교환기 레코드 검색에 이용
- CLI에서 gmail.com의 DNS 레코드를 검색해보면 아래와 같은 MX Record 표시
- ![8-2.png](images%2F8-2.png)
- 우선순위 값은 선호도를 나타내는 것으로, 값이 낮으면 우선순위가 높아서 선호되는 형식

#### 첨부 파일
- 첨부 파일은 이메일 메시지와 함께 전송되며, 일반적으로 Base64 인코딩 사용
- 일반적으로 첨부 파일에는 크기 제한이 있으며, 아웃룩(20MB), Gmail(25MB)로 제한된다
- 용량에 대한 설정이 가능하며, 개인/기업에 따라 다르다

### 전통적 메일 서버
- 전통적인 메일 서버는 보통 서버 한 대로 운용되며, 사용자가 많지 않을 때 잘 동작하는 시스템이다.

#### 전통적 메일 서버 아키텍처
전통적 메일서버는 아래와 같은 방식으로 구성된다.
![8-3.png](images%2F8-3.png)
1. 앨리스는 아웃룩 클라이언트에 로그인하여 이메일을 작성하고 '보내기' 버튼을 누른다. 이메일은 아웃룩 메일 서버로 전송되며, 아웃룩 클라이언트와 메일 서버 사이의 통신 프로토콜은 SMTP이다.
2. 아웃룩 메일 서버는 DNS 질의를 통해 수신사 SMTP 서버 주소를 찾는다. 이 경우에 gmail의 SMTP 서버 주소이며, 주소를 알고 나면 해당 메일 서버로 이메일을 보낸다. 메일 서버 간 통신 프로토콜도 SMTP다.
3. gmail 서버는 이메일을 저장하고 수신자는 밥이 읽어갈 수 있도록 한다.
4. 밥이 gmail에 로그인아면 지메일 클라이언트는 IMAP/POP 서버를 통해 새 이메일을 가져온다.

#### 저장소
![8-4.png](images%2F8-4.png)
- 전통적 메일 서버는 이메일을 파일 시스템의 디렉터리에 저장
- 각각의 이메일은 고유한 이름을 가진 별도 파일로 보관
- 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관하며 해당 목적으로 maildir이라는 이름의 디렉터리가 널리 이용된다.
- 파일과 디렉터리를 활용하는 방안은 사용자가 많지 않을 때는 잘 동작하나 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용하기는 곤란
- 이메일의 양이 많아지고 파일 구조가 복잡해지면 디스크 I/O에서 병목이 발생
- 이메일을 서버의 파일 시스템에 보관하기 때문에 가용성과 안정성에 대한 요구사항도 만족시킬 수 없음
- 더 안정적인 분산 데이터 저장소 계층이 필요
- 추가로 멀티미디어, 메일 thread, 검색, 레이블 등 다양한 기능을 지원하도록 발전하며, POP, IMAP, SMTP 같은 이메일 프로토콜은 오래 전에 발명되어 이러한 기능을 지원하도록 설계되지 않고, 수십거 명의 사용자를 지원하도록 확장할 수도 없었다.

### 분산 메일 서버
- 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결

#### 이메일 API
- 이메일 API의 의미는 메일 클라이언트마다, 이메일 생명주기 단계마다 달라질 수 있다.
  - 모바일 단말 클라리언트를 위한 SMTP/POP/IMAP API
  - 송신 출 메일 서버와 수신 측 메일 서버 간의 SMTP 통신
  - 대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API
- 이 책에서는 중요한 API만 다루며 일반적으로는 HTTP 프로토콜이 사용된다.

1. POST /v1/messages endpoint
   - To, Tc, Bcc 헤더에 명시된 수신자에게 메시지 전송
2. GET /v1/folders 엔드포인트
   - 주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.
   - 응답 형식
```text
[{
  id: String        고유한 폴더 식별자
  name: String      폴더 이름
                    RFC6154에 따르면, 기본 폴더는 다음 폴더 가운데 하나다. All, Archive, Drafts, Flagged, Junk, Sent, Trash
  user_id: String   계정 소유자 ID
}]
```
3. GET /v1/folders/{:folder_id/messages endpoint
   - 주어진 폴더 아래의 오든 메시지 반환
   - 페이지 분할 등을 지원해야하기 때문에 복잡할 수 있음
   - 응답 형식 : 메시지 객체 목록
4. GET /v1/messages
   - 주어진 특정 메시지에 대한 모든 정보를 반환
   - 메시지는 이메일 애플리케이션의 핵심 구성 요소로, 발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성
   - 응답 형식
```text
{
    user_id: String                     // 계정주의 ID
    from: name: String, email: String   // 발신자의 <이름, 이메일> 쌍
    to: [name: String, email: String]   // 수신자 <이름, 이메일> 쌍의 목록
    subject: String                     // 이메일 제목
    body: String                        // 이메일 본문
    is_read: Boolean                    // 수신자가 메시지를 읽었는지 여부
}
```

#### 분산 메일 서버 아키텍처
- 여러 서버 사시에 데이터를 동기화하는 것은 어려운 작업이고, 수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 아주 까다로운 문제를 풀어야 한다.
- 클라우드 기술을 활용하여 이런 문제를 쉽게 푸는 방법을 알아보자.
![8-5.png](images%2F8-5.png)

- 웹메일(webmail) : 사용자는 웹브라우저를 사용해 메일을 받고 보낸다.
- 웹서버 : 쉡서버는 사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당한다. 본 설계안의 경우 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등의 모든 이메일 API 요청은 전부 웹서버를 통한다.
- 실시간 서버 : 실시간 서버는 새로운 이메일 내역을 클라이언트에 실시간으로 전달되는 역할을 담당.
  지속성 연결을 맺고, 유지해야 하므로 상태 유지(stateful) 서버, 실시간 통신 지원 방안으로는 롱 폴링(long polling)이나 웹소켓(websocket) 등이 있다.
  이 중 웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있어 한가지 해결책은 기본적으로 웹소켓을 쓰되, 여의치 않으면 롱 폴링을 백업으로 이용하는 것이다.
  실제 메일 서버 플랫폼 중 웹소켓 위에 프로토콜을 구축한 사례로 아파치 제임스가 있으며, 웹소켓 위에 JMAP을 구현했다.
- 메타데이터 데이터베이스 : 이메일 제목, 본문, 발신인, 수신인 목록 등의 메타 데이터를 저장하는 DB
- 첨부 파일 저장소 : 아마존 S3와 같은 객체 저장소를 사용하며, 이미지나 동영상 등의 대용량 파일을 저장하는데 적합한 확장이 용이한 저장소 인프라이다. 첨부 파일로는 25MB 까지 붙일 수 있도록 하며, 카산드라 같은 컬럼 기반 NoSQL DB는 이 용도로 적합하지 않은대 이유는 아래와 같다.
  - 카산드라가 BLOB(Binary Large Object) 자료형을 지원하고 해당 자료형이 지원하는 데이터의 최대 크기가 2GB이긴 하지만 실직적으로는 1MB 이상의 파일을 지원하지 못한다.
  - 카산드라에 첨부 파일을 저장하면 레코드 캐시를 사용하기 어렵다. 첨부 파일이 너무 많은 메모리를 잡아먹을 것이기 때문이다.
- 분산 캐시 : 최근에 수신된 이메일은 자주 읽을 가능성이 높으르모 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다.
  리스크 같은 다양한 기능을 제공하고, 규모 확장도 용이하여 레디스를 사용하여 설계한다.
- 검색 저장소 : 분산 문서 저장소(distributed document store), 고속 텍스트 검색을 지원하는 역 인덱스(inverted index)를 자료 구조로 사용한다.

#### 이메일 전송 절차
![8-6.png](images%2F8-6.png)
이메일을 보내는 절차는 아래와 같다.
1. 사용자가 웹메일 환경에서 메일을 작성한 다음 전송 버튼을 누르고, 요청은 LB로 전송된다.
2. LB는 처리율 제한(rate limit) 한도를 넘지 않는 선에서 요청을 웹 서버로 전달한다.
3. 웹 서버는 아래의 역할을 담당한다.
   - 기본적인 이메일 검증 : 이메일 크기 한도처럼 사전에 미리 정의된 규칙을 사용하여 수신된 이메일을 검사한다.
   - 수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사 : 같아면 웹 서버는 이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사한다. 검사를 문제없이 통과한 이메일은 송신인의 '보낸 편지함'과 수신인의 '받은 편지함'에 저장된다. 수신인 측 클라이언트는 RESTful API를 사용하여 이메일을 바로 가져올 수 있으며, 4단계 이후는 수행할 필요가 없다.
4. 메시지 큐
   - 기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달, 큐에 넣기에 첨부 파일의 크기가 너무 큰 이메일의 경우 첨부 파일은 객체 저장소에 따로 저장하고 큐에 전달하는 이메일 안에는 해당 저장 위치에 대한 참조 정보만 보관
   - 기본적인 검증에 실패한 이메일은 에러 큐에 보관
5. 외부 전송 담당 SMTP 작업 프로세스는 외부 전송 큐에서 메시지를 꺼내 이메일의 스팸 및 바이러스 감염 여부 확인
6. 검증 절차를 통과한 이메일은 저장소 계층 내의 '보낸 편지함'에 저장
7. 외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송

- 외부 전송 큐에 보관되는 메시지에는 이메일을 생성하는데 모든 메타데이터가 포함되어 있으며, 분산 메시지 큐는 비동기적 메일 처리를 가능케하는 핵심적 컴포넌트
- 웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로써 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다.
- 외부 전송 큐의 크기를 모니터링할 때는 각별히 주의해야하며, 메일이 처리되지 않고 큐에 오랫동안 남아있으면 그 이유를 분석해야하는데 아래와 같은 이유가 있을 수 있다.
  - 수신자 측 메일 서버에 장애 발생 : 나중에 메일을 다시 전송해야하며, 지수적 백오프(Exponential Backoff)가 좋은 전략일 수 있다.
  - 이메일을 보낼 큐의 소비자 수가 불충분 : 더 많은 소비자를 추가하여 처리 시간을 단축하는 방안을 고려할 수 있음

#### 이메일 수신 절차
![8-7.png](images%2F8-7.png)
이메일을 수신하는 절차는 아래와 같다.
1. 이메일이 SMTP LB에 도착한다.
2. LB는 트래픽을 여러 SMTP 서버로 분산한다. SMTP 연결에는 이메일 수락 정책을 구성하여 적용할 수 있다. 예를 들어 유효하지 않은 이메일은 반송되도록 하면 불필요한 이메일 처리를 피할 수 있다.
3. 이메일은 첨부 파일이 큐에 들어가기 너무 큰 경우에는 첨부 파일 저장소 (S3)에 보관한다.
4. 이메일을 수신 이메일 큐에 넣는다. 이 큐는 메일 처리 작업 프로세스와 SMTP 서버 간의 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 한다. 갑자기 수신되는 이메일의 양이 폭증하는 경우 버퍼 역할도 한다.
5. 메일 처리 작업 프로세스(worker)는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할을 하며, 아래의 절차는 검증 작업이 끝난 이메일을 대상으로 한다.
6. 이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관
7. 수신자는 온라인 상태인 경우 이메일을 실시간 서버로 전달
8. 실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버
9. 오프라인 상태 사용자의 이메일은 저장소 계층에 보관한다. 해당 사용자가 온라인 상태가 되면 웹 메일 클라이언트는 웹 서버에 RESTful API를 통해 연결한다.
10. 웹 서버는 새로운 이메일을 저장소 계층에서 가져와 클라이언트네 반환한다.

## 3단계: 상세 설계
이메일 서버의 기본 구성 요소를 바탕으로 규모 확장 방안에 대해 점검

### 메타데이터 데이터베이스
- 메타데이터의 특성을 알아보고 올바른 데이터베이스와 데이터 모델을 고르고, 이메일 타래 지원 방안에 대해 알아보자.

#### 이메일 메타데이터의 특성
- 이메일의 헤더는 일반적으로 작고, 빈번하게 이용
- 본문의 크기는 작은 것부터 큰 것까지 다양하지만 사용 빈도는 낮으며, 일반적으로 한번만 읽는다.
- 이메일 가져오기, 읽은 메일일로 표시, 검색 등의 이메일 관련 작업은 사용자별로 격리 수행되어야 한다.
- 어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야 하고, 메일에 대한 작업도 그 사용자만 수행할 수 있어야 한다.
- 데이터의 신선도는 데이터 사용 패턴에 영향을 미친다. 사용자는 보통 최근 메일만 읽으며, 만들어진 지 16일 이하 데이터에 발생하는 읽기 질의 비율은 전체 질의의 82%에 달한다.
- 데이터의 높은 안정성이 보장되어야 한다. 데이터 손실은 용납되지 않는다.

#### 올바른 데이터베이스의 선정
- g-mail이나 아웃룩 정도의 규모가 되면 보통 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위해 맞춤 제작한 데이터 베이스를 사용, 여기서는 가능한 모든 선택지를 미리 살펴보며 비교를 진행
  - 관계형 데이터베이스 : 관계형 데이터베이스를 고르는 주된 동기는 이메일을 효율적으로 검색할 수 있기 때문, 이메일 헤더와 본문에 대한 인덱스를 만들어 두면 간단한 검색 질의를 빠르게 처리 가능
    관계형 데이터베이스는 데이터 크기가 작을 때 적합한대, 이메일은 수 KB보다 크고, HTML이 포함되면 100KB도 넘어감. BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있지 않느냐고 이야기할 수 있지만 비정형 BLOB 자료형 데이터에 대한 검색 질의 성능은 좋지 않으며, BLOB 자료형이 고정된 크기의 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생하기에 관계형 데이터베이스는 적합하지 않음
  - 분산 객체 저장소 : 이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 것
    객체 저장소는 백업 데이터를 보관하기에 좋지만 읽음 표시, 키워드 검색, 이메일 타래 등의 기능을 구현하기에는 그다지 좋지 않음
  - NoSQL 데이터베이스 : g-mail은 Bigtable을 저장소로 사용하며, 충분히 실현 가능한 방안이다. 하지만 Bigtable은 오픈소스로 공개되어 있지 않고 어떤 방식으로 구현했는지는 알지 못하기 때문에 카산드라가 좋은 대안이 될 수 있지만 아직 대형 이메일 서비스 제공 업체에서 카산드라가 사용되는 곳은 확인된바가 없다.
- 위와 같은 내용으로 해당 설계안이 필요로 하는 기능을 완벽히 지원하는 데이터베이스는 없다고 봐도 좋으며, 대형 이메일 서비스 업체는 대체로 독자적인 데이터베이스 시스템을 만들어 사용한다. 하지만 제한된 면접 시간에 새로운 분산 데이터베이스를 설계하고 구현할 시간이 없기에 아래의 요건을 충족해야 한다는 점을 설명하도록 한다.
  - 어떤 단일 컬름의 크기는 한 자릿수 MB정도일 수 있다.
  - 강력한 데이터 일관성이 보장되어야 한다.
  - 디스크 I/O가 최소화되도록 설계되어야 한다.
  - 가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.
  - 증분 백업이 쉬워야 한다.

#### 데이터 모델
데이터를 저장하는 한 가지 방법으로 user_id를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 방법
이 데이터 모델의 한가지 문제는 메시지를 여러 사용자와 공유할 수 없다는 것이지만, 본 면접의 요구사항과는 관계가 없어 고려하지 않는다.
위 내용을 바탕으로 테이블을 정의한다. 기본 키는 파티션 키(partition key)와 클러스터 키(cluter key)의 두 가지 부분으로 구성된다.
- 파티션 키 : 데이터를 여러 노드에 분산하는 역할, 일반적으로 통용되는 규칙은 데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야함
- 클러스터 키 : 같은 파티션에 속한 데이터를 정렬하는 역할

이메일 서비스의 데이터 계층은 아래의 질의에 대한 지원도 필요
- 주어진 사용자의 모든 폴더를 구한다.
- 특정 폴더 내의 모든 이메일을 표시한다.
- 메일을 새로 만들거나, 삭제하거나 가져온다.
- 이미 읽은 메일 전부, 또는 아직 읽지 않은 메일 전부를 가져온다.
- 보너스 점수를 받을 수 있는 질의 : 이메일 타래를 전부 가져온다.

##### 질의 1: 특정 사용자의 모든 폴더 질의
아래의 이미지와 같이 파티션 키는 user_id이며, 어떤 사용자의 모든 폴터는 같은 파티션 안에 있다.  
![8-1-table.png](images%2F8-1-table.png)

##### 질의 2: 특정 폴더에 속한 모든 이메일 표시
사용자가 자기 메일 폴더를 열면 이메일은 가장 최근 것부터 오래된 순서로 정렬되어 표시되며, 같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 <user_id, folder_id> 형태의 복합 파티션 키를 사용해야 한다.  
또한 시간순으로 메일을 정렬하기 위한 email_id(TIMEUUID)가 존재
![8-2-table.png](images%2F8-2-table.png)

##### 질의 3: 이메일 생성/삭제/수신
해당 질의를 지원하기 위해서는 2개의 테이블이 필요하며, 아래와 같은 query를 통해 이메일 상세 정보를 가져올 수 있다.  
```SQL
SELECT * FROM emails_by_user WHERE email_id = 123;
```
하나의 메일에 여러 첨부 파일이 있을 수 있으며, email_id와 filename 필드를 같이 사용하면 모든 첨부 파일을 질의할 수 있다.
![8-3-table.png](images%2F8-3-table.png)

##### 질의 4: 읽은, 또는 읽지 않은 모든 이메일
관계형 데이터베이스로 도메인 모델을 구현하는 경우 읽은 메일은 아래와 같이 질의할 수 있음  
```SQL
SELECT * FROM emails_by_folder
WHERE user_id = <user_id> and folder_id = <folder_id> and
  is_read = true
ORDER BY email_id
```
읽지 않은 메일의 경우 is_read 를 false로 변경하여 가지고 오는 형식으로 가지고 오면 된다.  
하지만 본 설계안에서 사용하는 데이터 모델은 NoSQL 데이터베이스이고 보통 파티션 키와 클러스터 키에 대한 질의만 허용한다.  
emails_by_folder 테이블의 is_read 필드는 여기에 해당하지 않으므로, 대부분의 NoSQL 데이터베이스는 위의 질의문을 실행하지 못한다.  
문제를 해결하기 위한 방법으로는 아래의 방법이 존재  
1. 모든 메시지를 가져온 다음 application 단에서 필터링 수행 - 대규모 서비스에서는 적합하지 않음
2. 테이블 비정규화를 통해 read_emails, unread_emails 2개의 테이블로 분할하여 저장 - 메일을 읽은 후 unread_emails -> read_emails로 전환 

NoSQL에서의 질의문은 아래와 같다.
```SQL
SELECT * FROM unread_emails
WHERE user_id = <user_id> and folder_id = <folder_id>
ORDER BY email_id;
```
![8-4-table.png](images%2F8-4-table.png)

##### 보너스: 이메일 타래 가져오기
이메일 타래(threads)는 많은 이메일 클라이언트가 지원하는 기능으로 모든 답장을 최초 메시지에 타래로 엮어 보여주는 기능  
사용자는 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게 된다.  
전통적으로 JWZ 같은 알고리즘을 통해 구현되며, 기존적 아이디어에 대해서만 살펴본다.  
이메일 헤더에는 보통 아래의 세가지 필드가 존재
![8-5-table.png](images%2F8-5-table.png)  
위의 필드들을 통해 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리로 로드되어 있는 경우 전체 대화 타래를 재구성해 낼 수 있게 된다.  

#### 일관성 문제
높은 가용성을 위해 다중화에 의존하는 분산 데이터베이스는 데이터베이스는 데이터 일관성과 가용성 사이 타협적인 결정을 내릴 수 밖에 없다.  
이메일 서비스는 데이터의 정확성이 아주 중요한 서비스로 











