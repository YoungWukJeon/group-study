## 클러스터 관점에서 구성요소

- 엘라스틱서치는 기본적으로 클러스터라는 단위로 데이터를 제공

#### 클러스터
- 클러스터(Cluster)는 데이터를 실제로 가지고 있는 노드의 모임
- 관련된 모든 노드들을 논리적으로 확장해서 클러스터라고 부름
- 같은 클러스터 내부의 데이터만 서로 공유가 가능
- Cross Cluster Search
    - 다수의 클러스터의 데이터를 한 번에 검색하는 것이 가능
    - 과거의 트라이브 노드(Tribe Node)라는 형태의 대체제(deprecated 예정)

#### 노드
- 실행 시 노드는 클러스터에 의해 UUID(Universally Unique IDentifier)가 할당됨
- 직접 이름을 설정 가능
- 노드는 내부에 다수의 인덱스를 가짐
- 각 인덱스는 다수의 문서를 가짐
- 모든 노드는 마스터 노드와 데이터 노드의 역할을 동시에 수행할 수 있도록 설정됨
- 실제 운영 시에는 역할에 따라 노드를 물리적으로 분리하는 것이 좋다.

#### 인덱스
- 엘라스틱서치 인덱스(Index)는 유사한 특성을 가지고 있는 문서를 모아둔 문서들의 컬렉션
- 인덱스명은 모두 소문자로 설정해야함
- 루씬 인덱스
    - 루씬에서는 전문을 분석하고 분석한 결과를 물리적인 디스크에 저장하는 인덱싱이라는 과정이 있다.
    - 이 과정에서 생성된 데이터를 인덱스(Index)라고 부름
    - 엘라스틱서치의 인덱스와는 다름

#### 문서
- 검색 대상이 되는 실제 물리적인 데이터
- 엘라스틱서치에서는 JSON 형식으로 표현
- 실제로는 물리적인 샤드 형태로 나눠져서 다수의 노드로 분산 저장

#### 샤드
- 데이터를 분산 저장하는 방식으로 손쉬운 수평 확장이 가능해진다.
- 샤드는 인덱스의 전체 데이터를 분산해서 가지고 있는 일종의 부분집합
- 각 샤드는 자신이 가지고 있는 데이터만으로도 독립적으로 검색 서비스가 가능
- 실제로 인덱스에 쿼리를 요청하면 인덱스가 가지고 있는 모든 샤드로 검색 요청이 전달되고 각 샤드에서 1차적으로 검색이 어루어진 후 그 결과를 취합해서 최종 결과를 제공

#### 레플리카
- 샤드의 복제본
- 엘라스틱서치에서는 레플리카를 이용한 페일오버 메커니즘을 제공
- 엘라스틱서치의 고가용성
    - 검색 시 샤드와 레플리카에서 병렬로 실행될 수 있기 때문에 검색 성능이 좋아지는 결과를 가져온다.

#### 세그먼트
- 엘라스틱서치는 루씬 라이브러리를 통해 대부분의 검색 기능을 제공
- 루씬에 데이터가 색인되면 데이터는 최소한의 단위인 토큰으로 분리되고 특수한 형태의 자료구조로 저장
- 이 자료구조를 세그먼트(Segment)라고 함
- 세그먼트는 읽기에 최적화된 자료구조로서 역색인이라는 특수한 형태로 변환되어 물리적인 디스크에 저장된다.

## 엘라스틱서치 샤드 vs 루씬 인덱스

- 루씬에서 IndexWriter는 데이터를 색인하는 클래스
- 루씬에서 IndexSearcher는 색인된 데이터를 검색 결과로 제공하는 클래스
- IndexWriter와 IndexSearcher를 가지고 색인과 검색을 동시에 제공하는 루씬 인스턴스를 루씬 인덱스라고 함
- 엘라스틱서치 인덱스는 물리적으로 분산된 엑라스틱서치 샤드를 논리적인 관점에서 하나의 거대한 데이터로 바라보는 것
- 루씬 인덱스는 세그먼트를 이용해 검색을 수행
- 하나의 샤드는 자체적으로 데이터를 색인하고 검색할 수 있는 가장 작은 크기의 단일 검색엔진
- 루씬 인덱스가 자기 자신이 가지고 있는 세그먼트 내에서만 검색이 가능
- 엘라스틱서치 샤드는 모든 샤드가 가지고 있는 세그먼트들을 논리적으로 통합해서 검색 가능
- 엘라스틱서치 샤드는 다수의 인스턴스 간에 데이터를 분산 저장할 수 있는 근간이 되고, 이를 통해 분산 클러스터를 구축하는 것이 가능

## 엘라스틱서치가 근실시간 검색을 제공하는 이유

