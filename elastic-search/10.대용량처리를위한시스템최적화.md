## 노드 실행환경과 JVM 옵션

- 독립적으로 실행 가능한 엘라스틱서치와는 달리 루씬은 독립적으로 실행될 수 없는 라이브러리 형태로 제공
- 루씬은 jar 형태로 배포

#### 실행 시 자바 8 이상을 사용해야 하는 이유
- 자바 8 이상에서 람다와 스트림 API 제공
    - 람다를 이용해 로직을 작성하고 스트림에 입력하면 다수의 CPU에서 동시에 데이터가 처리되고 모든 CPU에서 처리가 끝날때 까지 결과를 기다린다.
    - 이후 결과가 나오면 모든 결과를 하나로 모아서 돌려준다.
    - 일종의 맵리듀스(Map-Reduce)로 동작하게 되는 것이다.
    - 이러한 과정은 언어 차원에서 블랙박스로 이루어진다.

#### 엘라스틱서치에 적용된 JVM 옵션
- 제공되는 jvm.option 파일을 이용해 튜닝 설정
- 힙 크기가 1GB로 기본 설정된 이유는 엘라스틱서치를 실행할 수 있는 최소한의 힙 크기가 1GB이기 때문

## 힙 크기를 32GB 이하로 유지해야 하는 이유

- 너무 작은 힙 크기는 OOM(Out-Of-Memory) 오류를 발생시킬 수 있다.
- 너무 큰 힙 크기는 FullGC가 발생할 때 시스템 전체가 마비되는 STW(Stop The World)를 발생시킬 수도 있다.

#### 엘라스틱서치와 힙 크기
- 1GB로 설정된 값은 엘라스틱서치를 처음 사용하는 사용자들의 테스트를 위한 용도로 제공되는 값이며 최소 사양을 가정해서 설정된 값이다.
- JVM은 처음 실행될 때 Xms에 설정된 힙 크기로 동작하다가 힙이 부족하다고 판단되면 Xmx에 설정된 힙 크기까지 자동으로 늘어난다. 이 과정에서 애플리케이션의 성능 저하가 일어날 수 있다.
- 엘라스틱서치는 기본적으로 메모리를 많이 사용하는 애플리케이션이기 때문에 처음부터 Xms와 Xmx의 크기를 같게 설정하는 것이 여러모로 유리하다.
- 엘라스틱서치에서는 할당할 힙 크기의 최댓값으로 32GB 이하를 설정하는 것을 권장한다.
- 시스템 캐시는 운영체제가 가지고 있는 메모리 공간으로 커널 내부에 존재한다.
- 엘라스틱서치에서 32GB 이하로 힙 크기를 제한하는 것을 권장하는 이유는 핫스폿(Hot-Spot) JVM의 Object Pointer 정책 때문이다.
- Object Pointer는 간단히 말하자면 객체의 메모리 번지를 표현하는 주솟값이다.
- 32비트 JVM과 64비트 JVM 모두 기본적으로 2비트 주솟값을 가지고 동작한다. 그 이유는 모든 JVM이 기본적으로 32비트 Object Pointer를 사용하기 때문이다.

#### Ordinary Object Pointer
- JVM은 힙 영역에 생성된 객체에 접근하기 위해 포인터의 주소를 Ordinary Object Pointer(OOP)라고 하는 특수한 자료구조로 만들어서 관리한다.
- 시스템의 패러다임이 32비트 시스템에서 64비트 시스템으로 변화하면서 많은 물리적인 한계를 극복할 수 있었지만 상대적으로 메모리 공간의 낭비나 연산 속도 저하 등의 단점도 함께 나타났다.
- 자바에서는 이러한 문제를 해결하기 위해 기존의 OOP를 개선해서 Compressed OOP라는 새로운 개념의 포인터 관리 기법을 도입했다.

#### Compressed Ordinary Object Pointer
- JDK6에서 최초로 탑재되어 옵션으로 제공되다가 JDK7부터는 기본 설정으로 변경되어 사용되고 있다.
- 포인터의 공간 낭비를 줄이고 좀 더 빠른 연산을 위해 포인터를 압축해서 표현하는 일종의 트릭이라 할 수 있다.
- 포인터가 객체의 정확한 메모리 주소를 가리키게 하는 것이 아니라 상대적인 오브젝트 오프셋(Object Offset)을 가리키도록 살짝 변형해서 동작시키는 것이다.
- 64비트 시스템에서 Compressed OOP를 사용할 경우 포인터를 표현할 때 예외적으로 32비트 포인터를 사용해 동작한다.
- 이러한 트릭은 힙 크기가 32GB(2^32 * 8)를 넘어가면 더는 사용할 수 없다.
- JVM은 힙 크기가 32GB를 넘어가는 순간 Compressed OOP를 일반적인 64비트 OOP로 자동으로 변환한다.

#### 엘라스틱서치에서 힙 크기 설정하기
- 너무 큰 힙 크기는 시스템이 STW의 저주에 빠지게 만든다.
- 가급적이면 고성능 서버를 피하는 것이 좋다.
    - 64GB의 물리 메모리(OS: 32GB, ES: 32GB)를 탑재한 다수의 서브를 운영하는 편이 여러모로 유리하다.
- 전문(Full Text) 검색을 주목적으로 엘라스틱서치를 사용하는 경우에는 엘라스틱서치 힙에 32GB를 할당하고 나머지를 운영체제에 남겨둬서 루씬이 시스템 캐시를 통해 메모리를 최대한 사용할 수 있게 한다. 전문 검색의 경우 메모리 연산보다는 루씬의 역색인 구조를 이용하는 경우가 훨씬 많을 것이기 때문이다.
- 특정 데이터 타입(숫자, 날짜, geo_point, keyword)의 경우 필드가 별도의 분석 과정을 거치지 않는다. 이 경우에는 정렬이나 집계 시 루씬의 DocValues를 사용하기 때문에 힙 공간은 거의 사용되지 않는다. 엘라스틱서치 힙에 32GB를 할당하고 루씬이 나머지를 사용하도록 설정한다.
- 분석된 문자열 필드에서 정렬이나 집계를 수행할 경우에는 루씬의 DocValues를 사용할 수 없기 때문에 fielddata라는 힙 기반의 캐시를 사용해야 한다. 많은 힙 메모리가 필요하지만 위에서 설명한 이유로 32GB의 힙 크기를 가진 엘라스틱서치 인스턴스를 여러 개 생성하는 방식으로 설정하는 것이 좋다.
- 하나의 물리 서버에 다수의 엘라스틱서치 인스턴스가 있을 때 고가용성에 문제가 생길 수 있다.
    - cluster.routing.allocation.same_shard.host: true <- 이 옵션을 통해 같은 서버에 프라이머리 샤드와 레플리카 샤드가 배치되는 것을 최대한 방지할 수 있다.

#### 엘라스틱서치에서 Compressed OOP 사용하긱
- -XX:+UseCompressedOops
- JDK8 이상에서는 기본으로 이 옵션이 활성화돼 있다.
- Compressed OOP를 사용하기 위해 왜 32GB를 모두 사용하지 못하고 32GB에 조금 못 미치는 값을 사용하는 것일까?
    - 그 이유는 JVM의 힙 메모리가 0번지부터 시작되지 않기 때문이다.
    - 모든 시스템의 메모리가 0번지부터 사용된다면 좋겠지만 시스템마다 사용되는 시작 번지가 약간씩 달라진다.
    - 안전하게 31GB로 설정하는 것도 한 가지 방법일 수 있다.
- 자바에서는 힙 메모리에 8바이트 단위로 객체를 저장하는데, 이러한 특성을 이용하면 특정 객체를 찾아가기 위해 시프트(Shift) 연산을 사용하는 것이 가능해진다.
- 시스트 연산으로 생성된 값에 특정 번지수를 더하는 Add 연산이 추가로 병행돼야 정확한 번지수를 계산할 수 있다.
- Zero-Based Comopressed OOP는 JVM이 시작될 때 힙 메모리의 시작 번지가 0번지부터 시작되도록 논리적으로 강제한다.
- JVM에서는 모든 조건이 만족될 경우 자동으로 Zero-Based Compressed OOP로 동작한다.
- 엘라스틱서치에서는 JVM 성능을 위해 반드시 Compressed OOP를 사용하는 것을 권장한다.

## 엘라스틱서치 가상 메모리

- 현대 운영체제에서는 애플리케이션이 물리 메모리를 직접적으로 할당받지 못한다.

#### 가상 메모리
- 대부분의 현대 운영체제들은 가상 메모리(Virtual Memory)라는 메모리 관리 기법을 사용한다.

#### JVM을 위한 가상 메모리
- 운영체제에서는 효율적인 메모리 관리를 위해 메모리와 디스크 간에 데이터를 교환하는 스와핑(Swapping)이라는 작업을 꾸준히 수행한다.
- 프로그램이 동작하면서 메모리상에 필요한 부분들은 지속적으로 변경되고 이때마다 메모리와 디스크 간의 데이터 교환(Swapping)이 반복적으로 일어난다.

#### 엘라스틱서치를 위한 vm.max_map_count 설정
- 루씬은 내부적으로 자바에서 제공하는 NIO 기술을 활용한다.
- 이를 통해 운영체제 커널에서 제공하는 mmap 시스템콜을 직접 호출할 수 있으며 이를 이용하면 VM을 거치지 않고도 직접 커널 모드로 진입할 수 있긱 때문에 높은 성능을 낼 수 있다.
- 바로 커널 레벨의 파일 시스템 캐시를 사용할 수 있다는 점이다.
- 결과적으로 엘라스틱서치는 자바 힙 메모리도 사용할 수 있고 운영체제에 할당된 물리 메모리도 사용할 수 있는 일석이조의 결과를 누리게 된다.
- 엘라스틱서치에서 루씬이 원활하게 동작하기 위해서는 가상 메모리 설정 중 mmap 크기 항목을 변경해야한다. 대부분의 운영체제에서 기본적으로 제공도하는 설정 값이 너무 작기 때문이다.
- 엘라스틱서치에서는 이러한 문제를 미연에 방지하기 위해 vm.max_map_count 설정을 초기 로딩(Bootstrap) 과정에서 검사해서 수치가 262,114 이하이면 오류 메시지를 출력하고 인스턴스를 강제로 종료시킨다.
- 값을 영구적으로 설정하려면 /etc/sysctl.conf 파일에서 직접 vm.max_map_count를 설정해야 한다.

## 분산환경에서의 메모리 스와핑

#### 메모리 스와핑
- 대부분의 운영체제에서는 효율적인 메모리 관리를 위해 스와핑이라는 기술을 활용한다.
- 스와핑이 일어나면 가상 메모리의 일부 내용을 디스크로 쓰기 위해 디스크의 일정 영역을 스왑 영역으로 만든다.

#### 엘라스틱서치에서 스와핑을 비활성화해야 하는 이유
- 엘라스틱서치를 포함한 대부분의 분산 시스템에서는 전체적인 클러스터의 안정성을 해치는 것보다 문제가 발생한 노드가 강제로 종료되어 클러스터 구성에서 제외되는 편이 훨씬 더 효율적이다. 그러므로 엘라스틱서치에선는 어떠한 대가를 치르더라도 스와핑이 절대 발생하지 않게 해야 한다.
- 가장 좋은 것은 스와핑 기능을 완전히 비활성화하는 것이지만 모든 상황에서 이렇게 할 수는 없을 것이다.
- vm.swappiness 값을 1로 설정하면 스와핑을 최대한 이용하지 않겠다는 의미이며, 이 설정을 통해 일반적인 상황에서는 스와핑이 일어나지 않게 할 수 있다.
- memory_lock 설정
    - 루트 권한이 없을 경우
    - 엘라스틱서치의 환경설정으로 제공하고 있는 bootstrap.memory_lock 속성을 이용하는 방법
    - mlockall() 함수 : 호출한 프로세스의 페이징을 금지시키고 모든 메모리가 램(RAM)에 상주하는 것을 보장
    - 스와핑을 최소화하려면 가급적 루트 권한을 이용해 시스템 설정을 변경하는 것이 안전하다.
    - memory_lock 설정에 실패하는 대부분의 경우 운영체제의 리소스 제한 설정이 주요 원인이다.

##