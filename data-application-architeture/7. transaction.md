- 트랜잭션 : 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶은 방법

## 애매모호한 트랜잭션의 개념

새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 훨씬 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의했다.

### ACID의 의미

트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 의미하는 약어인 ACID로 잘 알려져 있다.<br>
그러나 현실에서는 데이터베이스마다 ACID 구현이 제각각이다.<br>
ACID 표준을 따르지 않는 시스템은 때로 **BASE** 라고 불린다.<br>
- 기본적으로 가용성을 제공하고(Basically Available), 유연한 상태를 가지며(Soft state), 최종적 일관성(Eventual consistency)을 지닌다는 뜻이다.

#### 원자성(Atomicity)

일반적으로 **원자적** 이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다.<br>
시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.<br>
여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋)될 수 없다면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야 한다.<br>
원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경은 효과가 있고 어떤 것은 그렇지 않은지 알기 어렵다.<br>
오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력은 ACID 원자성의 결정적인 특징이다.

#### 일관성(Consistency)

ACID 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 선언(불변식(invariant))이 있다는 것이다.<br>
데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.<br>
일반적으로 애플리케이션에서 데이터가 유효한지 아닌지를 정의하고 데이터베이스는 데이터를 저장할 뿐이다.<br>
원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 (ACID에서의) 일관성은 애플리케이션의 속성이다.

#### 격리성(Isolation)

ACID에서 **격리성** 은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.<br>
트랜잭션은 다른 트랜잭션을 방해할 수 없다.<br>
고전적인 데이터베이스 교과서에서는 격리성을 **직렬성** 이라는 용어로 공식화한다.<br>
직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다.<br>
데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션의 **순차적으로** (하나씩 차례대로) 실행됐을 때의 결과와 동일하도록 보장한다.

![7.1](images/7.1.jpg)

#### 지속성(Durability)

데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다.<br>
**지속성(durability)** 은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.<br>
복제 기능이 있는 데이터베이스에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미할 수 있다.

### 단일 객체 연산과 다중 객체 연산

**다중 객체 트랜잭션** 은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.<br>
어떤 사용자의 읽지 않은 메시지 개수를 보여주려면 다음과 같은 질의를 실행할 수 있다.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true;
```

그러나 이메일이 많으면 이 질의가 너무 느려서 읽지 않은 메시지 개수를 별개의 필드에 저장하고 싶을 것이다. (일종의 비정규화)<br>
그림 7-2에서 사용자 2는 이상 현상을 경험한다.<br>
우편함 목록에 읽지 않은 메시지 개수는 아직 증가되지 않아서 읽지 않은 메시지 개수가 0으로 나온다.<br>
격리성은 사용자 2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일을 없게 해준다.

![7.2](images/7.2.jpg)

![7.3](images/7.3.jpg)

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.<br>
어떤 특정 연결 내에서 BEGIN TRANSACTION 문과 COMMIT 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.<br>
반면 비관계형 데이터베이스는 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 뜻하지는 않는다.<br>
어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.

#### 단일 객체 쓰기

원자성은 장애 복구(crash recovery)용 로그를 써서 구현할 수 있고 격리성은 각 객체에 잠금을 사용해 (동시에 한 스레드만 객체에 접근하도록) 구현할 수 있다.<br>
증가 연산은 그림 7-1에 나온 read-modify-write 주기를 반복할 필요를 없앤다.<br>
비슷하게 유명한 것으로 compare-and-set 연산이 있다.<br>
이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)을 방지하므로 유용하다.

#### 다중 객체 트랜잭션의 필요성

단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있다.<br>
하지만 많은 다른 경우에는 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.

- 관계형 데이터 모델에서 다중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 올발라야 하고 최신 정보를 반영해야 한다.
- 문서 데이터 모델에서는 비정규화된 정보를 갱신할 때 한 번에 여러 문서를 갱신해야 한다.
- 보조 색인이 있는 데이터베이스에서는 값을 변경할 때마다 색인도 갱신돼야 한다.

원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.

#### 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.<br>
리더 없는 복제를 사용하는 데이터스토어는 "최선을 다하는(best effort)" 원칙을 기반으로 훨씬 더 많은 일을 한다.<br>
"데이터베이스는 가능한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다".<br>
따라서 오류 북구는 애플리케이션에게 책임이 있다.

## 완화된 격리 수준

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다.<br>
동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다.<br>
그러한 까닭에 데이터베이스는 오랫동안 **트랜잭션 격리** 를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.<br>
**직렬성** 격리는 데이터베이스가 여러 트랜잭션들이 **직렬적으로** 실행된다는 것과 동일한 결과가 나오도록 보장한다는 것을 의미한다.<br>
직렬성 격리는 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.<br>
맹목적으로 도구에 의존하기보다는 존재하는 동시성 문제의 종류를 잘 이해하고 방지하는 방법을 배울 필요가 있다.

### 커밋 후 읽기(read committed)

가장 기본적인 수준의 트랜잭션 격리는 **커밋 후 읽기** 고 다음 두 가지를 보장해준다.

1. 데이터베이스에서 읽을 때 커밋된 데이터만 보게 한다. (더티 읽기가 없음)
2. 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)

#### 더티 읽기 방지

트랜잭션이 데이터베이스에 데이터를 썼지만 아직 커밋되거나 어보트되지 않았다고 하자.<br>
다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있을까?<br>
만약 그렇다면 이를 **더티 읽기(dirty read)** 라고 한다.

![7.4](images/7.4.jpg)

더티 읽기를 막는 게 유용한 이유가 몇 가지 있다.
- 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스러우며 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수 있다.
- 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터, 즉 실제로는 데이터베이스에 결코 커밋되지 않을 데이터를 볼 수 있다.

#### 더티 쓰기 방지

먼저 쓴 내용이 아직 커밋되지 않는 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어 써버리면 어떻게 될까?<br>
이를 **더티 쓰기(dirty write)** 라고 부른다.<br>
보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용한다.<br>
더티 쓰기를 막음으로써 이 격리 수준은 몇 가지 동시성 문제를 회피한다.
- 웹 사이트에 있는 목록이 구매자를 반영하도록 갱신돼야 하고 판매 송장이 구매자에게 전송돼야 한다. 그림 7-5의 경우 밥에게 판매됐지만(밥이 목록 테이블을 최종 갱신) 송장은 앨리스에게 전송됐다(앨리스가 송장 테이블을 최종 갱신). 커밋 후 읽기는 이런 사고를 막아준다.
- 그림 7-1에서 나온 두 번의 카운터 증가 사이에 발생하는 경쟁 조건은 막지 못한다.

![7.5](images/7.5.jpg)

#### 커밋 후 읽기 구현

가장 흔한 방법으로 데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.<br>
오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있다.<br>
이런 잠금은 커밋 후 읽기 모드(또는 더 강한 격리 수준)에서 데이터베이스에 의해 자동으로 실행된다.<br>
그러나 읽기 잠금을 요구하는 방법은 현실에서는 잘 동작하지 않는다.<br>
읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문이다.<br>
이런 이유로 대부분의 데이터베이스는 그림 7-4에서 설명된 방법을 사용해 더티 읽기를 방지한다.<br>
해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다.<br>
새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된다.

### 스냅숏 격리(snapshot isolation)와 반복 읽기(repeatable read)

커밋 후 읽기(read committed) 격리 수준을 사용하더라도 동시성 버그가 생길 수 있는 경우가 아직 많이 있다.<br>

![7.6](images/7.6.jpg)

이런 이상 현상을 **비반복 읽기(nonrepeatable read)** 나 **읽기 스큐(read skew)** 라고 한다.<br>
몇 초 후 애플리케이션에서 데이터 리로드를 통해서 일관성이 지켜지는 경우(웹 사이트 새로고침 등)도 있다.<br>
어떤 상황에서는 이런 일시적인 비일관성을 감내할 수 없는 경우도 있다.

- 백업 : 백업을 하려면 데이터베이스 전체의 복사본을 만들어야 하는데 백업의 일부는 데이터의 과거 버전을, 다른 부분은 새 버전을 갖고 있을 수 있다.
- 분석 질의와 무결성 확인 : 데이터베이스의 큰 부분을 스캔하는 질의를 실행하고 싶을 때가 있다. 분석 작업에서 흔하거나 모든 것이 순차적으로 실행되는 주기적인 물결성 확인의 일부일 수도 있다.

**스냅숏 격리** 는 이런 문제의 가장 흔한 해결책이다.<br>
각 트랜잭션은 데이터베이스의 **일관된 스냅숏** 으로부터 읽는다.<br>
즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.

#### 스냅숏 격리 구현 (p238)

![7.7](images/7.7.jpg)

#### 일관된 스냅숏을 보는 가시성 규칙
#### 색인과 스냅숏 격리
#### 반복 읽기와 혼란스러운 이름

### 갱신 손실 방지

### 쓰기 스큐와 팬텀

![7.8](images/7.8.jpg)

## 직렬성

### 실제적인 직렬 실행

![7.9](images/7.9.jpg)

### 2단계 잠금(2PL)
### 직렬성 스냅숏 격리(SSI)

![7.10](images/7.10.jpg)

![7.11](images/7.11.jpg)

## 정리