- 트랜잭션 : 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶은 방법

## 애매모호한 트랜잭션의 개념

새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 훨씬 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의했다.

### ACID의 의미

트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 의미하는 약어인 ACID로 잘 알려져 있다.<br>
그러나 현실에서는 데이터베이스마다 ACID 구현이 제각각이다.<br>
ACID 표준을 따르지 않는 시스템은 때로 **BASE** 라고 불린다.<br>
- 기본적으로 가용성을 제공하고(Basically Available), 유연한 상태를 가지며(Soft state), 최종적 일관성(Eventual consistency)을 지닌다는 뜻이다.

#### 원자성(Atomicity)

일반적으로 **원자적** 이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다.<br>
시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.<br>
여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋)될 수 없다면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야 한다.<br>
원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경은 효과가 있고 어떤 것은 그렇지 않은지 알기 어렵다.<br>
오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력은 ACID 원자성의 결정적인 특징이다.

#### 일관성(Consistency)

ACID 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 선언(불변식(invariant))이 있다는 것이다.<br>
데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.<br>
일반적으로 애플리케이션에서 데이터가 유효한지 아닌지를 정의하고 데이터베이스는 데이터를 저장할 뿐이다.<br>
원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 (ACID에서의) 일관성은 애플리케이션의 속성이다.

#### 격리성(Isolation)

ACID에서 **격리성** 은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.<br>
트랜잭션은 다른 트랜잭션을 방해할 수 없다.<br>
고전적인 데이터베이스 교과서에서는 격리성을 **직렬성** 이라는 용어로 공식화한다.<br>
직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다.<br>
데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션의 **순차적으로** (하나씩 차례대로) 실행됐을 때의 결과와 동일하도록 보장한다.

![7.1](images/7.1.jpg)

#### 지속성(Durability)

데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다.<br>
**지속성(durability)** 은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.<br>
복제 기능이 있는 데이터베이스에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미할 수 있다.

### 단일 객체 연산과 다중 객체 연산

**다중 객체 트랜잭션** 은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.<br>
어떤 사용자의 읽지 않은 메시지 개수를 보여주려면 다음과 같은 질의를 실행할 수 있다.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true;
```

그러나 이메일이 많으면 이 질의가 너무 느려서 읽지 않은 메시지 개수를 별개의 필드에 저장하고 싶을 것이다. (일종의 비정규화)<br>
그림 7-2에서 사용자 2는 이상 현상을 경험한다.<br>
우편함 목록에 읽지 않은 메시지 개수는 아직 증가되지 않아서 읽지 않은 메시지 개수가 0으로 나온다.<br>
격리성은 사용자 2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일을 없게 해준다.

![7.2](images/7.2.jpg)

![7.3](images/7.3.jpg)

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.<br>
어떤 특정 연결 내에서 BEGIN TRANSACTION 문과 COMMIT 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.<br>
반면 비관계형 데이터베이스는 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 뜻하지는 않는다.<br>
어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.

#### 단일 객체 쓰기

원자성은 장애 복구(crash recovery)용 로그를 써서 구현할 수 있고 격리성은 각 객체에 잠금을 사용해 (동시에 한 스레드만 객체에 접근하도록) 구현할 수 있다.<br>
증가 연산은 그림 7-1에 나온 read-modify-write 주기를 반복할 필요를 없앤다.<br>
비슷하게 유명한 것으로 compare-and-set 연산이 있다.<br>
이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)을 방지하므로 유용하다.

#### 다중 객체 트랜잭션의 필요성

단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있다.<br>
하지만 많은 다른 경우에는 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.

- 관계형 데이터 모델에서 다중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 올발라야 하고 최신 정보를 반영해야 한다.
- 문서 데이터 모델에서는 비정규화된 정보를 갱신할 때 한 번에 여러 문서를 갱신해야 한다.
- 보조 색인이 있는 데이터베이스에서는 값을 변경할 때마다 색인도 갱신돼야 한다.

원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.

#### 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.<br>
리더 없는 복제를 사용하는 데이터스토어는 "최선을 다하는(best effort)" 원칙을 기반으로 훨씬 더 많은 일을 한다.<br>
"데이터베이스는 가능한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다".<br>
따라서 오류 복구는 애플리케이션에게 책임이 있다.

## 완화된 격리 수준

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다.<br>
동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다.<br>
그러한 까닭에 데이터베이스는 오랫동안 **트랜잭션 격리** 를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.<br>
**직렬성** 격리는 데이터베이스가 여러 트랜잭션들이 **직렬적으로** 실행된다는 것과 동일한 결과가 나오도록 보장한다는 것을 의미한다.<br>
직렬성 격리는 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.<br>
맹목적으로 도구에 의존하기보다는 존재하는 동시성 문제의 종류를 잘 이해하고 방지하는 방법을 배울 필요가 있다.

### 커밋 후 읽기(read committed)

가장 기본적인 수준의 트랜잭션 격리는 **커밋 후 읽기** 고 다음 두 가지를 보장해준다.

1. 데이터베이스에서 읽을 때 커밋된 데이터만 보게 한다. (더티 읽기가 없음)
2. 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)

#### 더티 읽기 방지

트랜잭션이 데이터베이스에 데이터를 썼지만 아직 커밋되거나 어보트되지 않았다고 하자.<br>
다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있을까?<br>
만약 그렇다면 이를 **더티 읽기(dirty read)** 라고 한다.

![7.4](images/7.4.jpg)

더티 읽기를 막는 게 유용한 이유가 몇 가지 있다.
- 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스러우며 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수 있다.
- 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터, 즉 실제로는 데이터베이스에 결코 커밋되지 않을 데이터를 볼 수 있다.

#### 더티 쓰기 방지

먼저 쓴 내용이 아직 커밋되지 않는 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어 써버리면 어떻게 될까?<br>
이를 **더티 쓰기(dirty write)** 라고 부른다.<br>
보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용한다.<br>
더티 쓰기를 막음으로써 이 격리 수준은 몇 가지 동시성 문제를 회피한다.
- 웹 사이트에 있는 목록이 구매자를 반영하도록 갱신돼야 하고 판매 송장이 구매자에게 전송돼야 한다. 그림 7-5의 경우 밥에게 판매됐지만(밥이 목록 테이블을 최종 갱신) 송장은 앨리스에게 전송됐다(앨리스가 송장 테이블을 최종 갱신). 커밋 후 읽기는 이런 사고를 막아준다.
- 그림 7-1에서 나온 두 번의 카운터 증가 사이에 발생하는 경쟁 조건은 막지 못한다.

![7.5](images/7.5.jpg)

#### 커밋 후 읽기 구현

가장 흔한 방법으로 데이터베이스는 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.<br>
오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있다.<br>
이런 잠금은 커밋 후 읽기 모드(또는 더 강한 격리 수준)에서 데이터베이스에 의해 자동으로 실행된다.<br>
그러나 읽기 잠금을 요구하는 방법은 현실에서는 잘 동작하지 않는다.<br>
읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문이다.<br>
이런 이유로 대부분의 데이터베이스는 그림 7-4에서 설명된 방법을 사용해 더티 읽기를 방지한다.<br>
해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다.<br>
새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된다.

### 스냅숏 격리(snapshot isolation)와 반복 읽기(repeatable read)

커밋 후 읽기(read committed) 격리 수준을 사용하더라도 동시성 버그가 생길 수 있는 경우가 아직 많이 있다.<br>

![7.6](images/7.6.jpg)

이런 이상 현상을 **비반복 읽기(nonrepeatable read)** 나 **읽기 스큐(read skew)** 라고 한다.<br>
몇 초 후 애플리케이션에서 데이터 리로드를 통해서 일관성이 지켜지는 경우(웹 사이트 새로고침 등)도 있다.<br>
어떤 상황에서는 이런 일시적인 비일관성을 감내할 수 없는 경우도 있다.

- 백업 : 백업을 하려면 데이터베이스 전체의 복사본을 만들어야 하는데 백업의 일부는 데이터의 과거 버전을, 다른 부분은 새 버전을 갖고 있을 수 있다.
- 분석 질의와 무결성 확인 : 데이터베이스의 큰 부분을 스캔하는 질의를 실행하고 싶을 때가 있다. 분석 작업에서 흔하거나 모든 것이 순차적으로 실행되는 주기적인 무결성 확인의 일부일 수도 있다.

**스냅숏 격리** 는 이런 문제의 가장 흔한 해결책이다.<br>
각 트랜잭션은 데이터베이스의 **일관된 스냅숏** 으로부터 읽는다.<br>
즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.

#### 스냅숏 격리 구현

스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적인 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다.<br>
스냅숏 격리의 핵심 원리는 **읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽으 결코 차단하지 않는다** 는 것이다.<br>
스냅숏 격리를 구현하기 위해 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.<br>
데이터베이스가 객체의 여러 버전을 함께 유지하므로 이 기법은 **다중 버전 동시성 제어(multi-version concurrency control, MVCC)** 라고 한다.<br>
전형적인 방법은 커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 것이다.<br>
트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID(txid)를 할당받는다.<br>
트랜잭션이 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다.

![7.7](images/7.7.jpg)

#### 일관된 스냅숏을 보는 가시성 규칙

면밀하게 가시성 규칙을 정의함으로써 데이터베이스는 데이터베이스의 일관된 스냅숏을 애플리케이션에게 제공할 수 있다.

1. 데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인(아직 커밋이나 어보트가 되지 않은) 모든 트랜잭션의 목록을 만든다.
2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다.

아래 두 조건이 모두 참이면 객체를 볼 수 있다.

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

오래 실행되는 트랜잭션은 오랫동안 스냅숏을 사용해서 덮어써지거나 삭제된 지 오래된 값을 계속 읽을 수도 있다.<br>
데이터베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅숏을 제공할 수 있다.

#### 색인과 스냅숏 격리

포스트그레스큐엘은 동일한객체의 다른 버전들이 같은 페이지(page)에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 한다.<br>
카우치DB, 데이토믹, LMDB에서는 다른 방법을 쓴다.<br>
이것들도 B 트리를 사용하지만 **추가 전용이며 쓸 때 복사되는(append-only/copy-on-write)** 변종을 사용한다.<br>
트리의 페이지가 갱신될 때 덮어쓰는 대신 각 변경된 페이지의 새로운 복사본을 생성한다.

#### 반복 읽기와 혼란스러운 이름

스냅숏 격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에 유용하다.<br>
오라클에서는 **직렬성** , 포스트그레스큐엘과 MySQL에서는 **반복 읽기(repeatable read)** 라고 한다.

### 갱신 손실 방지

두 트랜잭션이 동시에 카운터를 증가시키는 것은 **갱신 손실(lost update)** 은 대표적인 예이다.<br>
갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때(read-modify-write 주기) 발생할 수 있다.<br>
이런 패턴은 다양한 시나리오에서 발생한다.

- 카운터를 증가시키거나 계좌 잔고를 갱신한다.
- 복잡한 값을 지역적으로 변경한다.
- 전체 페이지 내용을 서버에 보내서 현재 데이터베이스에 저장된 내용을 덮어 쓰도록 만들어진 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.

#### 원자적 쓰기 연산

여러 데이터베이스에서 원자적 갱신 연산을 제공한다.<br>
다음 명령은 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.

```sql
UPDATE counters SET `value` = `value` + 1 WHERE `key` = 'foo';
```

몽고DB 같은 문서 데이터베이스는 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공하고 레디스는 우선순위 큐(priority queue) 같은 데이터 구조를 변경하는 원자적 연산을 제공한다.<br>
원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해 구현한다.<br>
이 기법을 **커서 안정성(cursor stability)** 이라고 부르기도 한다.<br>
다른 선택지는 그냥 모든 원자적 연산을 단일 스레드에서 실행하도록 강제하는 것이다.<br>
객체 관계형 매핑 프레임워크를 사용하면 뜻하지 않게 데이터베이스가 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 주기를 실행하는 코드를 작성하기 쉽다.

#### 명시적인 잠금

데이터베이스에 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다.

```sql
BEGIN TRANSACTION;

SELECT * FROM figures
    WHERE `name` = 'robot' AND game_id = 222
    FOR UPDATE;

-- 이동이 유효한지 확인한 후
-- 이전의 SELECT에서 반환된 것의 위치를 갱신한다.

UPDATE figures SET position = 'c4' WHERE id = 1234;

COMMIT;
```

#### 갱신 손실 자동 감지

대안으로 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다.<br>
이 방법의 이점은 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 것이다.<br>
MySQL/InnoDB의 반복 읽기(repeatable read)는 갱신 손실을 감지하지 않는다.<br>
갱신 손실 감지는 애플리케이션 코드에서 어떤 특별한 데이터베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능이다.

#### Compae-and-set

트랜잭션을 제공하지 않는 데이터베이스 중에는 원자적 compare-and-set 연산을 제공하는 것도 있다.<br>
이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다.

```sql
-- 데이터베이스 구현에 따라 안전할 수도 안전하지 않을 수도 있다
UPDATE wiki_pages SET content = 'new content'
    WHERE id = 1234 AND content = 'old content';
```

#### 충돌 해소와 복제

여러 노드에 데이터의 복사본이 있어서 데이터가 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다.<br>
잠금과 compare-and-set 연산은 데이터의 최신 복사본이 하나만 있다고 가정한다.<br>
이렇게 복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전( **형제(sibling)** 라고도 한다)을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것이다.<br>
**최종 쓰기 승리(last write wins, LWW)** 충돌 해소 방법은 갱실 손실이 발생하기 쉽다.<br>
유감스럽게도 많은 복제 데이터베이스는 LWW가 기본 설정이다.

### 쓰기 스큐와 팬텀

![7.8](images/7.8.jpg)

## 직렬성

### 실제적인 직렬 실행

![7.9](images/7.9.jpg)

### 2단계 잠금(2PL)
### 직렬성 스냅숏 격리(SSI)

![7.10](images/7.10.jpg)

![7.11](images/7.11.jpg)

## 정리