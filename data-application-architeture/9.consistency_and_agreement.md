# 일관성과 합의 

8장에서 설명했지만 분산 시스템에서는 많은 것들이 잘못될 수 있다.<br/>
이런 결함을 다루는 가장 간단한 방법은 사용자에게 오류 메시지 노출하는 것<br/>
하지만 결합을 견뎌낼(tolerating) 서비스 구축하기 위해서는 방법을 찾아야 한다.<br/>
<br/>
이번 장에서 다룰 내용
- **내결함성** 을 지닌 분산 시스템을 구축하는데 쓰이는 알고리즘과 프로토콜 몇 가지 소개 
- 8장에서 설명한 모든 문제가 발생할 수 있다고 가정한다.
  - 네트워크에서 패킷 손실 
  - 패킷의 순서가 바뀌거나 중복됨
  - 임의의 시간에 응답 지연
- 분산 시스템의 가능한 한계, 불가능한 한계의 개요 

내결함성을 지닌 시스템을 구축하는 좋은 방법은 **내결함성을 보장해주는 범용 추상화** 를 찾아 이를 구현하는 것<br/>
7장에서 설명한 트랜잭션 추상화가 하나의 범용 추상화이다.
- 트랜잭션 추상화로 어플리케이션은 충돌, 경쟁 조건, 디스크 장애 문제를 걱정하지 않아도 됨 

분산 시스템에서 가장 중요한 추상화 중 하나는 **합의** 이다.<br/>
합의는 모든 노드가 어떤 것에 동의하도록 만드는 것<br/>
ex) 단일 리더를 복제하는 데이터베이스 
- 리더가 죽어서 새 리더를 선출할 때 합의를 사용할 수 있음 
- 두 노드가 자신이 리더라고 생각하는 상황을 **스플릿 브레인(split brain)** 이라 부르며 이는 데이터 손실이 종종 발생함
- 올바르게 구현된 합의는 이런 문제들을 피하는데 도움이 됨 

먼저 분산 시스템에서 **제공될 수 있는 보장과 추상화의 범위** 를 알아봐야 함 <br/>
어떤 것을 할 수 있고 어떤 것을 할 수 없는지에 대한 범위를 이해해야 함 <br/>
이런 가능한 한계, 불가능한 한계는 구현 측면에서 깊이 연구되어왔고 자료도 많지만 이번 장에서 모두 다루기에는 힘듬<br/>
- 공식적인 모델과 증명에 대한 것들은 참고 문헌 참고 

## 일관성 보장 
"복제 지연 문제" 에서 데이터베이스에서 발생하는 **타이밍 문제** 가 있었음 
- 동시에 데이터베이스 2개 노드를 본다면 각 노드에서 서로 다른 데이터를 볼 가능성이 크다. 
- 노드들에 쓰기 요청이 도착하는 시간이 다르기 때문 
- 이런 불일치는 데이터베이스가 어떤 복제 방법(단일 리더, 다중 리더, 리더 없는 복제 등) 을 사용하든지 항상 일어남 

복제 데이터 베이스는 대부분 **최종적 일관성** 을 제공한다.
- 최종적 일관성 : 불특정 시간동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환 

그러나 이것은 매우 약한 보장이다. **언제 복제본이 수렴(최종적 일관성)될지에 대해서는 모르기 때문이다.** <br/>
약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 알아야 하고 너무 많은 것을 가정해서는 안된다.<br/>
대부분의 시간에는 잘 동작할 수 있기 때문에 버그는 테스트로 발견하기 어렵다. <br/>
최종적 일관성의 에지 케이스는 시스템에 결함(네트워크 끊킴)이 있거나 동시성이 높을 때만 분명히 드러난다.<br/>

분산 일관성 모델과 트랜잭션 격리 수준 계층은 비슷한 점이 있다.(232p 완화된 격리수준 참고)<br/>
그러나 겹치는 부분이 있어도 이들은 독립적인 관심하이다.
- 트랜잭션 격리는 동시에 실행되는 트랜잭션 때문에 발생하는 **경쟁 조건을 회피** 하는 것에 관한 것 
- 분산 일관성은 지연과 결함이 있어도 복제본의 상태를 **코디네이션** 하는 것에 관한 것 

### 선형성 
최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본에 같은 query 동시에 하면 다른 응답을 받을 수 있다.<br/>
복제본이 하나만 있다는 환상을 만들어 주면 어떨까 ? <br/>
그러면 모든 클라이언트는 똑같이 데이터를 보고 복제 지연을 걱정할 필요가 없다. <br/>
<br/>
이것이 **선형성** 을 뒷바침하는 아이디어 이다.
- 선형성은 **원자적 일관성(atomic consistency)**, **강한 일관성(strong consistency)**, **즉각 일관성(immediate consistency)**, **외부 일관성(external consistency)** 라고도 함 

선형성의 정의는 매우 미묘하며 뒤에서 살펴본다.<br/>
기본 아이디어는 시스템에 **데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것 처럼 만드는 것** 이다..<br/>
이런 보장이 있다면 실제로 여러 복제본이 있더라도 어플리케이션은 거기에 신경 쓸 필요가 없다.<br/>
<br/>
전형성 시스템에서는 클라이언트가 쓰기를 완료하면 모든 클라이언트는 해당 값을 읽을 수 있어야 한다.<br/>
복사본이 하나만 있다는 환상을 유지하기 위해서는 해당 값이 최신 값이며 캐시나 복제본에서 나온 값이 아니라고 보장해주어야 한다.<br/>
선형성은 **최신성 보장(recency guarantee)** 이다.<br/>
이 아이디어를 명확하기 하기 위해 **비선형 시스템의 예** 를 보자 <br/>
<br/>
비선형 스포츠 웹사이트 <br/>
![not_linearizable](images/9-1_not_linearizable.png) <br/>
- 앨리스와 밥은 같은 방에서 휴대폰으로 2014 월드컵 결승전 결과를 확인하고 있다.
- 앨리스는 웹 페이지에서 우승팀이 결정된 것을 보고 밥에게 말한다.
- 밥은 휴대폰으로 새로고침 하지만 그 요청은 지연된 데이터베이스 복제본으로 전달되어 아직 경기중인것으로 보인다. 
- 밥은 앨리스가 최종 결과를 외친 것을 들은 후에 새로고침 버튼을 눌렀기 때문에 최신 값이 노출될 것으로 기대했다.
- 밥의 요청이 오래된 결과를 반환 했다는 것은 선형성 위반이다.

### 시스템에 선형성을 부여하는 것은 무엇인가 ? 
선형성 데이터베이스에서 동시에 같은 키(x) 를 읽고 쓰는 3 클라이언트의 예<br/>
분산 시스템 분야에서 x 는 **레지스터** 라고 불린다.<br/>
![concurrent_read_request](images/9-2_concurrent_read_request.png) <br/>
각 막대는 요청을 보낸 시점과 응답을 받은 시간을 나타낸다.
- x 의 값은 처음에 0 이고 C 가 값을 1로 설정하는 쓰기를 수행 
- 쓰기가 실행되는 동안 A와 B는 최신 값을 읽기 위해 데이터베이스를 폴링한다.
- 쓰기가 완료되지 않았을때 A와 B는 0 or 1 을 반환했을 수 있다. 읽기 연상이 처리되는 시점에 쓰기에 영향을 발생했는지 알 수 없기 때문이다.
- A는 3번째 읽기에서 쓰기가 완료되었기 때문에 1을 반환받았다.

그러나 위 그림은 선형성을 완전히 설명하기에는 부족하다.<br/>
쓰기와 동시에 실행되는 읽기가 오래된 값 or 새로운 값 반환하기 때문에 A와 B의 읽기에서 선형성이 깨질 수 있다.<br/> 
이것은 "데이터의 단일 복사본" 을 모방하는 시스템에서 기대하는 바가 아니다.<br/>
<br/>

시스템을 선형적으로 만드려면 9-3 처럼 다른 제약조건을 추가해야 함 <br/>
- 선형적 시스템에서 우리는 x의 값이 0에서 1로 바뀌는 어떤 시점이 있어야 한다고 가정한다.
- 따라서 한 클라이언트가 새로운 값(1) 을 읽었다면 이후 모든 읽기는 새로운 값을 반환해야 한다.
- 쓰기 연산이 아직 완료되지 않았더라도 말이다.

![concurrent_read_request_after](images/9-3_concurrent_read_request_after.png) <br/> 
- A는 2번째 읽기에서 새로운 값 1을 읽었다.
- 그 다음으로 B가 읽기를 수행하면 새로운 값 1을 읽어야 한다. 
- 아직 쓰기가 진행중이라도 말이다.

이 타이밍 다이어그램을 더 개선해서 어떤 시점에 원자적으로 영향을 주는 개별 연산을 시각화 할 수 있다.<br/>
이번에 추가되는 다이어그램에서는 새로운 연산이 추가된다. 
> cas(x, v<sub>old</sub>, v<sub>new</sub>) => r <br/>
> 클라이언트가 원자적 연산(compare-and-set) 을 요청했다는 뜻이다. <br/>
> x 의 현재 값 = v<sub>old</sub> 이면, v<sub>new</sub> 로 설정되어야 한다. <br/>
> 값이 같지 않으면 레지스터를 그대로 두고 오류를 반환해야 한다.


![9-4_concurrent_read_request_visualizing_point](images/9-4_concurrent_read_request_visualizing_point.png) <br/> 
- B 가 읽기 요청을 보낸 후 D 가 x 를 0 으로 설정하는 요청을 하고 A 가 1로 설정하는 요청을 보낸다.
- B 읽기가 반환한 값은 1 (A가 쓰기한 값) 이다.
  - 이것은 문제가 없다. 데이터베이스가 D 의 쓰기 이후에 A 의 쓰기를 처리했고 마지막으로 B 의 읽기를 처리했다는 의미이다.
- 이 모델은 어떤 트랜잭션 격리도 가정하지 않는다. C는 처음 읽을때 1을 반환했지만 2번째 읽을때 2를 반환했다.
- B, C, D 는 cas(compare and set) 연산을 수행하는데 B와 C는 성공하지만 D 는 실패한다.
- B의 마지막 읽기는 **선형적이지 않다.** 
- C 의 cas 연산으로 x 는 2 > 4 로 변경되었고 A 는 이미 x 의 4를 읽었기 때문에 B 는 과거의 값을 읽는것은 허용되지 않는다.

이것이 선형성 뒤에 있는 직관이다.<br/>
모든 요청과 응답 시점을 기록하고 그것들이 유효한 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트 할 수 있다.<br/>
<br/>
> **선형성 대 직렬성**
> 선형성은 직렬성과 혼동하기 쉽다. 두 단어 모두 "순차적인 순서로 배열될 수 있는" 무언가를 의미하기 때문이다.<br/>
> 그러나 이들은 매우 다른 보장이며 구별하는게 중요하다.<br/>
> <br/>
> 직렬성<br/>
> 직렬성은 **트랜잭션들의 격리 속성** 이다. 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 실제로 실행되는 순서와 관련없이 말이다.<br/>
> <br/>
> 선형성<br/>
> 선형성은 레지스터에 실행되는 읽기와 쓰기에 대한 **최신성 보장**이다. 선형성 연산은 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.<br/>
> <br/>
> 데이터 베이스는 직렬성, 선형성을 모두 제공 할 수도 있으며 이런 조합은 **엄격한 직렬성(strict serializability)** 이나 **강한 단일 복사본 직렬성(strong one-copy serializability, strong-1SR)** 이라고 한다.<br/>
> 2단계 잠금(256p)이나 실제적인 직렬실행(252p)을 기반으로 한 직렬성 구현은 보통 선형적이다.<br/>
> <br/>
> 그러나 직렬성 스냅숏 격리(260p) 는 선형적이지 않다. 설계상 잠금 경쟁을 피하기 위해서 일관된 스냅숏에서 읽는다.<br/>
> 따라서 스냅숏 보다 나중에 실행된 쓰기가 포함되지 않으며 스냅숏에서 읽기를 수행하면 이것은 선형적이지 않다.<br/>

## 선형성의 기대기 
어떤 환경에서 선형성이 유용할까? <br/>
스포츠 시합의 최종 점수 조회는 시시한 예이다. 이 상황에서 결과가 몇 초 뒤쳐진다고 해도 손해를 유발할 가능성은 거의 없다.<br/>
그러나 선형성이 중요한 요구사항이 되는 영역이 몇 가지 있다.
- 잠금과 리더 선출 
- 제약 조건과 유일성 보장 
- 채널 간 타이밍 의존성 

### 잠금과 리더 선출
단일 리더 복제를 사용하는 시스템은 리더가 여러개(스플릿 브레인) 가 아니라 하나만 존재하도록 보장해야함.<br/>
스플릿 브레인을 방지하는 방법 중 하나는 **잠금** 을 이용하는 것이다.<br/>
노드들은 시작할 때 잠금을 획득하고 성공한 노드가 리더가 된다.<br/>
이 잠금은 **선형적** 이어야 하며 모든 노드들은 특정 노드가 잠금을 갖고 있다면 리더가 되는 것에 동의해야 한다.<br/>
<br/>
분산 잠금과 리더 선출을 구현하기 위해 코디네이션 서비스가 사용된다.
- 아파치 주키퍼(Apache Zookeeper)
- etcd
- 아파치 큐레이터(Apache Curator)

이런 코디네이션 서비스는 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.<br/>
- 이런 알고리즘은 361p "내결함성을 지닌 합의" 에서 설명 

잠금과 리더 선출을 구현하기 위해서는 미묘한 세부 사항이 많은데, (301p "리더와 잠금"에 나온 펜싱 문제)<br/>
아파치 큐레이터(Apache Curator) 는 주키퍼 위에서 고수준 레시피를 제공하여 도움을 준다.<br/>
이런 코디네이션 작업에는 선형성 저장소 서비스가 기초적인 기반이 된다.<br/>
<br/>
분산 잠금은 오라클 리얼 어플리케이션 클러스터(Oracle Real Application Cluster, RAC) 같은 분산 데이터베이스에서 세분화된 수준으로 사용되기도 함<br/>
RAC 는 여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근하며 디스크 페이지 마다 잠금을 사용한다.<br/>
선형성 잠금은 트랜잭션 실행의 중요 경로(critical path)에 있어서 RAC 를 배치할 때는 보통 데이터베이스 노드들 상이의 통션용으로 전용 클러스터 연결 네트워크를 사용한다.

### 제약 조건과 유일성 보장 
유일성 제약 조건은 데이터베이스에서 흔한 일이다. <br/>
ex) 사용자명, 이메일 주소<br/>
데이터가 기록될 때 제약 조건을 강제하고 싶다면 **선형성이 필요** 하다.<br/>
이런 유일성 제약 조건은 잠금, compare-and-set 연산과 비슷하다.<br/>
> 제약 조건을 구현하는 방법의 차이라고 생각된다.

<br/>

하지만 조금 더 복잡한 제약 조건들도 있다.
- 은행 잔고가 음수가 되지 않게 하기
- 재고의 갯수 보다 더 많이 팔지 않게 하기 

이런 복잡한 제약 조건은 모든 노드가 동의하는 하나의 최신 값이 있기를 요구한다.<br/>
<br/>
실제 어플리케이션에서 때때로 이런 제약 조건을 느슨하게 다루는 경우도 있다.<br/>
- 예를들어 항공편이 초과 예약 됐다면 고객에게 다른 항공편으로 옮기고 불편함에 대한 보장을 지급할 수 있다.
- 이런 경우에는 선형성이 필요 없을 수 있다. 
- (523p "적시성과 무결성" 에서 느슨하게 이해되는 제약 조건을 살펴볼 예정)

그러나 관계형 데이터베이스에서 볼 수 있는 엄격한 유일성 제약 조건은 선형성이 필요하다.<br/>
- 외래키나 속성 제약 조건 같은 다른 종류의 제약조건은 선형성 없이도 구현가능 

### 채널 간 타이밍 의존성 
그림 9-1 에서 앨리스가 승리 팀을 외치지 않았다면 밥은 자신의 질의 결과가 뒤쳐졌다는 것을 알지 못했을 것이다.<br/>
**선형성 위반** 은 시스템에 부가적인 통신 채널이 있었기 때문에 발견됐다.(앨리스의 소리 > 밥의 귀)<br/>
<br/>
컴퓨터 시스템에서 예를 보자.<br/>
사용자들이 이미지를 업로드 하면 백그라운드 프로세스가 이미지를 저해상도로 바꾸는(썸네일) 웹 사이트가 있다.<br/>
![website_race_condition](images/9-5_website_race_condition.png) <br/>
- 사용자가 이미지를 업로드 하면 이미지는 웹 서버를 통해 파일 저장소에 저장됨 
- 웹 서버는 메시지 큐에 메시지를 전달하고 
- 이미지 크기 변경 모듈은 메시지 큐를 통해 파일 저장소의 이미지를 가져와 크기 변경 후 파일 저장소에 다시 저장한다.

파일 저장 서비스가 선형적이면 시스템을 잘 동작한다.<br/>
하지만 선형적이지 않다면 **경쟁 조건** 의 위험이 있다.<br/>
- 웹 서비스에서 이미지 크기 변경 모듈까지 메시지를 전달하는 것(3 ~ 4번 과정)이 파일 저장소의 이미지 복제(2번 이후 파일 저장소 내부) 보다 빠를 수 있다.
- 이때 이미지 크기 변경 모듈이 이미지를 읽으면 과거의 이미지를 읽거나 이미지를 읽지 못할 수 있다.

이 문제는 웹 서버와 크기 변경 모듈 사이에 두 가지 통신 채널(파일 저장소, 메시지 큐)이 존재하기 때문에 발생한다.<br/>
따라서 선형성의 최신성 보장이 필요하다.<br/>
선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기 가장 단순하다.<br/>
선형성을 만들기 위해 복잡성을 추가 하는 대신 164p "자신이 쓴 내용 읽기" 와 같은 대안을 사용할 수도 있다. 

## 선형성 시스템 구현하기 
