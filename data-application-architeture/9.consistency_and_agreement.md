# 일관성과 합의 

8장에서 설명했지만 분산 시스템에서는 많은 것들이 잘못될 수 있다.<br/>
이런 결함을 다루는 가장 간단한 방법은 사용자에게 오류 메시지 노출하는 것<br/>
하지만 결함을 견뎌낼(tolerating) 서비스 구축하기 위해서는 방법을 찾아야 한다.<br/>
<br/>
이번 장에서 다룰 내용
- **내결함성** 을 지닌 분산 시스템을 구축하는데 쓰이는 알고리즘과 프로토콜 몇 가지 소개 
- 8장에서 설명한 모든 문제가 발생할 수 있다고 가정한다.
  - 네트워크에서 패킷 손실 
  - 패킷의 순서가 바뀌거나 중복됨
  - 임의의 시간에 응답 지연
- 분산 시스템의 극복 가능한 한계, 극복 불가능한 한계의 개요 

내결함성을 지닌 시스템을 구축하는 좋은 방법은 **내결함성을 보장해주는 범용 추상화** 를 찾아 이를 구현하는 것<br/>
7장에서 설명한 트랜잭션 추상화가 하나의 범용 추상화이다.
- 트랜잭션 추상화로 어플리케이션은 충돌, 경쟁 조건, 디스크 장애 문제를 걱정하지 않아도 됨 

분산 시스템에서 가장 중요한 추상화 중 하나는 **합의** 이다.<br/>
합의는 모든 노드가 어떤 것에 동의하도록 만드는 것<br/>
ex) 단일 리더를 복제하는 데이터베이스 
- 리더가 죽어서 새 리더를 선출할 때 합의를 사용할 수 있음 
- 두 노드가 자신이 리더라고 생각하는 상황을 **스플릿 브레인(split brain)** 이라 부르며 이는 데이터 손실이 종종 발생함
- 올바르게 구현된 합의는 이런 문제들을 피하는데 도움이 됨 

먼저 분산 시스템에서 **제공될 수 있는 보장과 추상화의 범위** 를 알아봐야 함 <br/>
어떤 것을 할 수 있고 어떤 것을 할 수 없는지에 대한 범위를 이해해야 함 <br/>
이런 가능한 한계, 불가능한 한계는 구현 측면에서 깊이 연구되어왔고 자료도 많지만 이번 장에서 모두 다루기에는 힘듬<br/>
- 공식적인 모델과 증명에 대한 것들은 참고 문헌에서 확인해라 

## 일관성 보장 
"복제 지연 문제" 에서 데이터베이스에서 발생하는 **타이밍 문제** 가 있었음 
- 동시에 데이터베이스 2개 노드를 본다면 각 노드에서 서로 다른 데이터를 볼 가능성이 크다. 
- 노드들에 쓰기 요청이 도착하는 시간이 다르기 때문 
- 이런 불일치는 데이터베이스가 어떤 복제 방법(단일 리더, 다중 리더, 리더 없는 복제 등) 을 사용하든지 항상 일어남 

복제 데이터 베이스는 대부분 **최종적 일관성** 을 제공한다.
- 최종적 일관성 : 불특정 시간동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환 

그러나 이것은 매우 약한 보장이다. **언제 복제본이 수렴(최종적 일관성)될지에 대해서는 모르기 때문이다.** <br/>
약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 알아야 하고 너무 많은 것을 가정해서는 안된다.<br/>
대부분의 시간에는 잘 동작할 수 있기 때문에 버그는 테스트로 발견하기 어렵다. <br/>
최종적 일관성의 에지 케이스는 시스템에 결함(네트워크 끊킴)이 있거나 동시성이 높을 때만 분명히 드러난다.<br/>

분산 일관성 모델과 트랜잭션 격리 수준 계층은 비슷한 점이 있다.(232p 완화된 격리수준 참고)<br/>
그러나 겹치는 부분이 있어도 이들은 독립적인 관심사이다.
- 트랜잭션 격리는 동시에 실행되는 트랜잭션 때문에 발생하는 **경쟁 조건을 회피** 하는 것에 관한 것 
- 분산 일관성은 지연과 결함이 있어도 복제본의 상태를 **코디네이션** 하는 것에 관한 것 

### 선형성 
최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본에 같은 query 동시에 하면 다른 응답을 받을 수 있다.<br/>
복제본이 하나만 있다는 환상을 만들어 주면 어떨까 ? <br/>
그러면 모든 클라이언트는 똑같이 데이터를 보고 복제 지연을 걱정할 필요가 없다. <br/>
<br/>
이것이 **선형성** 을 뒷바침하는 아이디어 이다.
- 선형성은 **원자적 일관성(atomic consistency)**, **강한 일관성(strong consistency)**, **즉각 일관성(immediate consistency)**, **외부 일관성(external consistency)** 라고도 함 

선형성의 정의는 매우 미묘하며 뒤에서 살펴본다.<br/>
기본 아이디어는 시스템에 **데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것 처럼 만드는 것** 이다..<br/>
이런 보장이 있다면 실제로 여러 복제본이 있더라도 어플리케이션은 거기에 신경 쓸 필요가 없다.<br/>
<br/>
선형성 시스템에서는 클라이언트가 쓰기를 완료하면 모든 클라이언트는 해당 값을 읽을 수 있어야 한다.<br/>
복사본이 하나만 있다는 환상을 유지하기 위해서는 해당 값이 최신 값이며 캐시나 복제본에서 나온 값이 아니라고 보장해주어야 한다.<br/>
선형성은 **최신성 보장(recency guarantee)** 이다.<br/>
이 아이디어를 명확하기 하기 위해 **비선형 시스템의 예** 를 보자 <br/>
<br/>
비선형 스포츠 웹사이트 <br/>
![not_linearizable](images/9-1_not_linearizable.png) <br/>
- 앨리스와 밥은 같은 방에서 휴대폰으로 2014 월드컵 결승전 결과를 확인하고 있다.
- 앨리스는 웹 페이지에서 우승팀이 결정된 것을 보고 밥에게 말한다.
- 밥은 휴대폰으로 새로고침 하지만 그 요청은 지연된 데이터베이스 복제본으로 전달되어 아직 경기중인것으로 보인다. 
- 밥은 앨리스가 최종 결과를 외친 것을 들은 후에 새로고침 버튼을 눌렀기 때문에 최신 값이 노출될 것으로 기대했다.
- 밥의 요청이 오래된 결과를 반환 했다는 것은 선형성 위반이다.

### 시스템에 선형성을 부여하는 것은 무엇인가 ? 
선형성 데이터베이스에서 동시에 같은 키(x) 를 읽고 쓰는 3 클라이언트의 예<br/>
분산 시스템 분야에서 x 는 **레지스터** 라고 불린다.<br/>
![concurrent_read_request](images/9-2_concurrent_read_request.png) <br/>
각 막대는 요청을 보낸 시점과 응답을 받은 시간을 나타낸다.
- x 의 값은 처음에 0 이고 C 가 값을 1로 설정하는 쓰기를 수행 
- 쓰기가 실행되는 동안 A와 B는 최신 값을 읽기 위해 데이터베이스를 폴링한다.
- 쓰기가 완료되지 않았을때 A와 B는 0 or 1 을 반환했을 수 있다. 읽기 연산이 처리되는 시점에 쓰기에 영향을 발생했는지 알 수 없기 때문이다.
- A는 3번째 읽기에서 쓰기가 완료되었기 때문에 1을 반환받았다.

그러나 위 그림은 선형성을 완전히 설명하기에는 부족하다.<br/>
쓰기와 동시에 실행되는 읽기가 오래된 값 or 새로운 값 반환하기 때문에 A와 B의 읽기에서 선형성이 깨질 수 있다.<br/> 
이것은 "데이터의 단일 복사본" 을 모방하는 시스템에서 기대하는 바가 아니다.<br/>
<br/>

시스템을 선형적으로 만드려면 9-3 처럼 다른 제약조건을 추가해야 함 <br/>
- 선형적 시스템에서 우리는 x의 값이 0에서 1로 바뀌는 어떤 시점이 있어야 한다고 가정한다.
- 따라서 한 클라이언트가 새로운 값(1) 을 읽었다면 이후 모든 읽기는 새로운 값을 반환해야 한다.
- 쓰기 연산이 아직 완료되지 않았더라도 말이다.

![concurrent_read_request_after](images/9-3_concurrent_read_request_after.png) <br/> 
- A는 2번째 읽기에서 새로운 값 1을 읽었다.
- 그 다음으로 B가 읽기를 수행하면 새로운 값 1을 읽어야 한다. 
- 아직 쓰기가 진행중이라도 말이다.

이 타이밍 다이어그램을 더 개선해서 어떤 시점에 원자적으로 영향을 주는 개별 연산을 시각화 할 수 있다.<br/>
이번에 추가되는 다이어그램에서는 새로운 연산이 추가된다. 
> cas(x, v<sub>old</sub>, v<sub>new</sub>) => r <br/>
> 클라이언트가 원자적 연산(compare-and-set) 을 요청했다는 뜻이다. <br/>
> x 의 현재 값 = v<sub>old</sub> 이면, v<sub>new</sub> 로 설정되어야 한다. <br/>
> 값이 같지 않으면 레지스터를 그대로 두고 오류를 반환해야 한다.


![9-4_concurrent_read_request_visualizing_point](images/9-4_concurrent_read_request_visualizing_point.png) <br/> 
- B 가 읽기 요청을 보낸 후 D 가 x 를 0 으로 설정하는 요청을 하고 A 가 1로 설정하는 요청을 보낸다.
- B 읽기가 반환한 값은 1 (A가 쓰기한 값) 이다.
  - 이것은 문제가 없다. 데이터베이스가 D 의 쓰기 이후에 A 의 쓰기를 처리했고 마지막으로 B 의 읽기를 처리했다는 의미이다.
- 이 모델은 어떤 트랜잭션 격리도 가정하지 않는다. C는 처음 읽을때 1을 반환했지만 2번째 읽을때 2를 반환했다.
- B, C, D 는 cas(compare and set) 연산을 수행하는데 B와 C는 성공하지만 D 는 실패한다.
- B의 마지막 읽기는 **선형적이지 않다.** 
- C 의 cas 연산으로 x 는 2 > 4 로 변경되었고 A 는 이미 x 의 4를 읽었기 때문에 B 는 과거의 값을 읽는것은 허용되지 않는다.

이것이 선형성 뒤에 있는 직관이다.<br/>
모든 요청과 응답 시점을 기록하고 그것들이 유효한 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트 할 수 있다.<br/>
<br/>
> **선형성 대 직렬성**
> 선형성은 직렬성과 혼동하기 쉽다. 두 단어 모두 "순차적인 순서로 배열될 수 있는" 무언가를 의미하기 때문이다.<br/>
> 그러나 이들은 매우 다른 보장이며 구별하는게 중요하다.<br/>
> <br/>
> 직렬성<br/>
> 직렬성은 **트랜잭션들의 격리 속성** 이다. 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 실제로 실행되는 순서와 관련없이 말이다.<br/>
> <br/>
> 선형성<br/>
> 선형성은 레지스터에 실행되는 읽기와 쓰기에 대한 **최신성 보장**이다. 선형성 연산은 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.<br/>
> <br/>
> 데이터 베이스는 직렬성, 선형성을 모두 제공 할 수도 있으며 이런 조합은 **엄격한 직렬성(strict serializability)** 이나 **강한 단일 복사본 직렬성(strong one-copy serializability, strong-1SR)** 이라고 한다.<br/>
> 2단계 잠금(256p)이나 실제적인 직렬실행(252p)을 기반으로 한 직렬성 구현은 보통 선형적이다.<br/>
> <br/>
> 그러나 직렬성 스냅숏 격리(260p) 는 선형적이지 않다. 설계상 잠금 경쟁을 피하기 위해서 일관된 스냅숏에서 읽는다.<br/>
> 따라서 스냅숏 보다 나중에 실행된 쓰기가 포함되지 않으며 스냅숏에서 읽기를 수행하면 이것은 선형적이지 않다.<br/>

## 선형성의 기대기 
어떤 환경에서 선형성이 유용할까? <br/>
스포츠 시합의 최종 점수 조회는 시시한 예이다. 이 상황에서 결과가 몇 초 뒤쳐진다고 해도 손해를 유발할 가능성은 거의 없다.<br/>
그러나 선형성이 중요한 요구사항이 되는 영역이 몇 가지 있다.
- 잠금과 리더 선출 
- 제약 조건과 유일성 보장 
- 채널 간 타이밍 의존성 

### 잠금과 리더 선출
단일 리더 복제를 사용하는 시스템은 리더가 여러개(스플릿 브레인) 가 아니라 하나만 존재하도록 보장해야함.<br/>
스플릿 브레인을 방지하는 방법 중 하나는 **잠금** 을 이용하는 것이다.<br/>
노드들은 시작할 때 잠금을 획득하고 성공한 노드가 리더가 된다.<br/>
이 잠금은 **선형적** 이어야 하며 모든 노드들은 특정 노드가 잠금을 갖고 있다면 리더가 되는 것에 동의해야 한다.<br/>
<br/>
분산 잠금과 리더 선출을 구현하기 위해 코디네이션 서비스가 사용된다.
- 아파치 주키퍼(Apache Zookeeper)
- etcd
- 아파치 큐레이터(Apache Curator)

이런 코디네이션 서비스는 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.<br/>
- 이런 알고리즘은 361p "내결함성을 지닌 합의" 에서 설명 

잠금과 리더 선출을 구현하기 위해서는 미묘한 세부 사항이 많은데, (301p "리더와 잠금"에 나온 펜싱 문제)<br/>
아파치 큐레이터(Apache Curator) 는 주키퍼 위에서 고수준 레시피를 제공하여 도움을 준다.<br/>
이런 코디네이션 작업에는 선형성 저장소 서비스가 기초적인 기반이 된다.<br/>
<br/>
분산 잠금은 오라클 리얼 어플리케이션 클러스터(Oracle Real Application Cluster, RAC) 같은 분산 데이터베이스에서 세분화된 수준으로 사용되기도 함<br/>
RAC 는 여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근하며 디스크 페이지 마다 잠금을 사용한다.<br/>
선형성 잠금은 트랜잭션 실행의 중요 경로(critical path)에 있어서 RAC 를 배치할 때는 보통 데이터베이스 노드들 사이에 통신용으로 전용 클러스터 연결 네트워크를 사용한다.

### 제약 조건과 유일성 보장 
유일성 제약 조건은 데이터베이스에서 흔한 일이다. <br/>
ex) 사용자명, 이메일 주소<br/>
데이터가 기록될 때 제약 조건을 강제하고 싶다면 **선형성이 필요** 하다.<br/>
이런 유일성 제약 조건은 잠금, compare-and-set 연산과 비슷하다.<br/>
> 제약 조건을 구현하는 방법의 차이라고 생각된다.

<br/>

하지만 조금 더 복잡한 제약 조건들도 있다.
- 은행 잔고가 음수가 되지 않게 하기
- 재고의 갯수 보다 더 많이 팔지 않게 하기 

이런 복잡한 제약 조건은 모든 노드가 동의하는 하나의 최신 값이 있기를 요구한다.<br/>
<br/>
실제 어플리케이션에서 때때로 이런 제약 조건을 느슨하게 다루는 경우도 있다.<br/>
- 예를들어 항공편이 초과 예약 됐다면 고객에게 다른 항공편으로 옮기고 불편함에 대한 보상을 지급할 수 있다.
- 이런 경우에는 선형성이 필요 없을 수 있다. 
- (523p "적시성과 무결성" 에서 느슨하게 이해되는 제약 조건을 살펴볼 예정)

그러나 관계형 데이터베이스에서 볼 수 있는 엄격한 유일성 제약 조건은 선형성이 필요하다.<br/>
- 외래키나 속성 제약 조건 같은 다른 종류의 제약조건은 선형성 없이도 구현가능 

### 채널 간 타이밍 의존성 
그림 9-1 에서 앨리스가 승리 팀을 외치지 않았다면 밥은 자신의 질의 결과가 뒤쳐졌다는 것을 알지 못했을 것이다.<br/>
**선형성 위반** 은 시스템에 부가적인 통신 채널이 있었기 때문에 발견됐다.(앨리스의 소리 > 밥의 귀)<br/>
<br/>
컴퓨터 시스템에서 예를 보자.<br/>
사용자들이 이미지를 업로드 하면 백그라운드 프로세스가 이미지를 저해상도로 바꾸는(썸네일) 웹 사이트가 있다.<br/>
![website_race_condition](images/9-5_website_race_condition.png) <br/>
- 사용자가 이미지를 업로드 하면 이미지는 웹 서버를 통해 파일 저장소에 저장됨 
- 웹 서버는 메시지 큐에 메시지를 전달하고 
- 이미지 크기 변경 모듈은 메시지 큐를 통해 파일 저장소의 이미지를 가져와 크기 변경 후 파일 저장소에 다시 저장한다.

파일 저장 서비스가 선형적이면 시스템을 잘 동작한다.<br/>
하지만 선형적이지 않다면 **경쟁 조건** 의 위험이 있다.<br/>
- 웹 서비스에서 이미지 크기 변경 모듈까지 메시지를 전달하는 것(3 ~ 4번 과정)이 파일 저장소의 이미지 복제(2번 이후 파일 저장소 내부) 보다 빠를 수 있다.
- 이때 이미지 크기 변경 모듈이 이미지를 읽으면 과거의 이미지를 읽거나 이미지를 읽지 못할 수 있다.

이 문제는 웹 서버와 크기 변경 모듈 사이에 두 가지 통신 채널(파일 저장소, 메시지 큐)이 존재하기 때문에 발생한다.<br/>
따라서 선형성의 최신성 보장이 필요하다.<br/>
선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기 가장 단순하다.<br/>
선형성을 만들기 위해 복잡성을 추가 하는 대신 164p "자신이 쓴 내용 읽기" 와 같은 대안을 사용할 수도 있다. 

## 선형성 시스템 구현하기 
선형성은 "데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적" 이라는 것을 의미한다.<br/>
선형성을 구현하는 가장 간단한 방법은 데이터 복사본을 하나만 사용하는것이다.<br/>
그러나 이 방법으로는 결함을 견뎌낼 수 없다. (복사본을 저장한 노드에 장애가 발생 할 수 있음)<br/>
<br/>
시스템이 내결함성을 갖도록 하기 위해서 **복제** 를 사용할 수 있다. 5장에서 다뤘던 복제 방법을 살펴보면서 선형적으로 만들 수 있는지 확인해보자.
- 단일 리더 복제(선형적이 될 가능성이 있음)
  - 단일 리더 복제에서 리더는 쓰기에 사용되는 데이터의 주 복사본을 갖고 있고 팔로워는 데이터 백업 복사본을 보관함 
  - 리더나 동기식으로 복제되는 팔로워에서 실행된 읽기는 **선형적이 될 가능성이 있다**
  - 그러나 단일 리더 복제를 사용하는 데이터베이스가 실제로 선형적인 것은 아니다.
  - 스냅숏 격리와 같은 설계 때문이거나 동시성 버그 때문일 수 도 있다.
- 합의 알고리즘(선형적)
  - 이번 장 후반부에서 설명할 어떤 합의 알고리즘은 단일 리더 복제를 유사함 
  - 그러나 합의 프로토콜에는 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수단이 포함되어 선형성 저장소를 안전하게 구현할 수 있음 
  - ex) etcd 나 주키퍼가 이렇게 동작함 
- 다중 리더 복제(비선형적)
  - 다중 리더 복제 시스템은 일반적으로 선형적이지 않다. 
  - 여러 노드에서 동시에 쓰기를 처리하고 다른 노드에서 비동기로 복제를 수행하기 때문이다.
  - 이런 이유로 다중 리더 복제 시스템은 충돌 쓰기가 발생할 수 있다.(173p 참고)
  - 이런 충돌은 단일 복사본만 존재하는게 아니기 때문에 발생하는 부산물이다.
- 리더 없는 복제(아마도 비선형적)
  - 리더 없는 복제 시스템에서 때때로 정족수 읽기와 쓰기(w + r > n)를 요구 함으로써 "엄격한 일관성" 을 달성할 수 있다고 주장하는 사람들이 있다.
  - 하지만 정족수 설정에 따라 엄격한 일관성을 어떻게 정의하느냐에 따라서 위 주장은 사실이 아니다.
  - 일 기준 시계를 기반으로 한 "최종 쓰기 승리" 충돌 해소 방법은 거의 비선형적이다. 
  - 시계 타임 스탬프는 시계 스큐(clock skew) 때문에 이벤트의 실제 순서와 일치한다고 보장할 수 없기 때문이다. 
  - 바로 다음에 설명하겠지만 엄격한 정족수를 사용하더라도 비선형적일 수 있다. 

### 선형성과 정족수 
다이나모 스타일 모델(179p)에서 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보인다.<br/>
그러나 아래 그림에서 처럼 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있다.<br/>
![nonlinear_strict_quorum](images/9-6_nonlinear_strict_quorum.png) <br/>
- x 의 초기값은 0 이며 쓰기 클라이언트는 3개 복제본에 x = 1 쓰기 요청 (n = 3, w = 3)
  - n : 복제 서버 
  - w : 쓰기를 수행할 서버 수  
- 클라이언트 A는 2개 노드로 구성된 정족수로부터 읽기를 수행해 1 을 확인 (r = 2)
- 클라리언트 B도 2개 노드에서 읽기를 수행해서 0 을 확인
- 정족수의 조건이 만족 (w + r > n) 됨에도 이 실행은 선형적이지 않다.
  - A 보다 B 가 나중에 요청하여 응답을 받았지만 최신 값이 추출되지 않음 

성능이 떨어지는 비용을 지불하면 다이나모 스타일 정족수를 선형적으로 만드는게 가능하다.<br/>
- 읽기 클라이언트는 결과를 어플리케이션에 반환하기 전에 읽기 복구를 동기식으로 수행(180p "읽기 복구와 안티 엔트로피")
- 쓰기 클라이언트는 쓰기 요청전에 정족수로부터 최신 값을 읽은 후 쓰기를 수행 

정족수를 사용하는 데이터베이스 시스템 
- 리악은 성능상 불이익 때문에 동기식 읽기를 수행하지 않음 
- 카산드라는 정족수 읽기를 할 때 읽기 복구를 기다리지만, **최종 쓰기 승리** 충돌 해소 방법을 쓰기 때문에 같은 키에 동시에 쓰기를 수행하면 선형성을 잃게된다. 

이 방법을 이용하면 선형성 읽기와 쓰기를 구현할 수 있다. 하지만 compare-and-set 연산은 합의 알고리즘이 필요하기 때문에 구현할 수 없다.<br/>
결론적으로 리더 없는 복제는 **선형성을 제공하지 않는다.** 라고 보는게 안전하다.

### 선형성의 비용
다중 리더 복제는 다중 데이터센터의 아키텍쳐에서 좋은 선택이다.(170p)<br/>
두 데이터센터 사이에 네트워크 끊기면 무슨일이 생길까?<br/>
각 데이터센터 내부 네트워크는 정상 동작하고 데이터센터 끼리는 서로 연결할 수 없다고 가정한다.<br/>
<br/>
다중 리더 데이터베이스를 사용하면 데이터센터는 정상 동작한다.<br/> 
![choice_linearizability_availability](images/9-7_choice_linearizability_availability.png) <br/>
- 한 데이터센터에 쓰여진 내용이 비동기로 다른 데이터센터로 복제되기 때문에 쓰기는 그냥 큐에 쌓였다가 네트워크 연결이 복구되면 복제가 재개된다.

반면 단일 리더 복제를 사용하면 문제가 생긴다.<br/>
- 리더는 특정 데이터센터에 위치하며 모든 쓰기와 선형성 읽기는 리더로 전달되어야 한다.
- 따라서 팔로워 데이터센터에 접속한 클라이언트의 읽기와 쓰기 요청은 네트워크를 통해 동기식으로 리더 데이터센터로 전송되어야 한다.
- 데이터센터 사이의 네트워크가 끊기면 팔로워 데이터센터에 접속한 클라이언트는 아무것도 쓸 수 없고 선형성 읽기도 전혀 할 수 없다.
- 팔로워로 부터 읽을 수는 있지만 데이터가 비선형적일 수 있다. (최신 값이 아님)
- 클라이언트가 리더 데이터센터로 접속할 수 있다면 문제가 되지 않지만, 팔로워 데이터센터에만 접속할 수 있는 클라이언트는 네트워크가 복구되기 전까지 중단을 경험한다.

### CAP 정리 
이 문제는 단일 리더 복제나 다중 리더 복제의 문제는 아니며 **어떤 선형성 데이터 베이스라도 이 문제가 있다.**<br/>
이 문제는 다중 데이터 센터 뿐만 아니라 신뢰성 없는 네트워크, 한 데이터센터 내에서도 발생 할 수 있다.<br/>
트레이드 오프 
- 어플리케이션에서 선형성이 요구됨
  - 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 복제서버는 연결이 끊긴 동안 요청을 처리할 수 없다.
  - 네트워크가 복구될 때까지 기다려야 한다. (가용성이 없다.)
- 어플리케이션에서 선형성이 요구되지 않음 
  - 각 복제서버가 다른 복제서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리가능하다.
  - 어플리케이션은 네트워크 문제에 **가용한 상태** 를 유지하지만 선형적이지 않다.

따라서 선형성이 필요없는 어플리케이션은 **네트워크 문제에 더 강인하다.**<br/>
이런 통찰력은 2000년대 에릭 브루어(Eric Brewer) 가 이름 붙인 **CAP 정리** 로 널리 알려졌다.<br/>
CAP 는 원래 데이터베이스에서 트레이드 오프에 대한 논의를 위한 목적으로 정확한 정의는 없고 경험 법칙으로 제안됐다.<br/>
당시에는 많은 분산 데이터베이스가 공유 저장소를 장비 클러스터에서 선형성 시민틱을 제공하는데 중점을 두었다.<br/>
CAP 는 데이터베이스 엔지니어가 대규모 웹 서비스를 구현하는 데 더 적합한 분산 비공유 시스템의 설계를 장려했다.<br/>
- 2000년대 중반부터 새로운 데이테비이스 기술(NoSQL)이 폭발적으로 증가함 
- CAP 는 이런 새로운 데이터베이스 기술에 문화적 변화의 공로가 있음 

공식적으로 정의된 CAP 는 매우 범위가 좁다.
- 오직 하나의 일관성 모델(선형성)과 하나의 결함(네트워크 분단)만 고려함
- 네트워크 지연, 죽은 노드 처럼 다른 트레이드 오프에 대해서는 어떤 언급도 없다.

따라서 CAP 는 역사적인 영향력은 있지만 실용적인 가치는 거의 없다.<br/>

> **도움이 안되는 CAP 정리** <br/>
> CAP = Consistency(일관성), Availability(가용성), Partition tolerance(분단 내성) <br/>
> CAP 는 세 개 중 2개를 고르라는 식으로 표현되는데 이것은 오해의 소지가 있다.<br/>
> **네트워크 분단** 은 일종의 결함이기 때문에 선택할 수 있는 것이 아니며, 좋든 싫든 발생한다.<br/>
> 네트워크의 결함이 생기면 **선형성** 과 **완전한 가용성** 사이에서 선택해야 한다. <br/>
> 따라서 CAP 는 **네트워크 분단이 생겼을 경우 선형성과 가용성 중에 하나를 선택** 하라는 의미로 보는게 좋다.<br/>
> <br/>
> CAP 의 가용성은 몇 가지 모순된 정의가 있고 공식적인 정리는 보통의 의미에 부합하지 않는다.<br/>
> 일반적인 "고가용성" 시스템들은 CAP 의 가용성에 대한 정의를 만족하지 않는다.(CAP 가용성의 정의가 이상하다는 뜻)<br/>
> CAP 는 시스템을 이해하는데 도움을 주지 않으므로 피하는게 최선이다.

### 선형성과 네트워크 지연 
선형성은 유용한 보장이지만 현실에서 선형적인 시스템은 놀랄만큼 드물다.<br/>
ex) 최신 다중코어 CPU 의 RAM <br/>
- 하나의 CPU 코어에서 실행 중인 스레드가 메모리 주소에 write 한 뒤 
- 다른 CPU 코어에서 실행되는 스레드가 같은 주소를 읽으면 
- 이전 스레드가 write 한 값을 읽을 것이라고 보장하지 않는다.(메모리 베리어나 펜스를 쓰지 않으면)
- 이렇게 동작하는 이유는 각 CPU 는 메모리 캐시와 저장 버퍼를 갖고 있기 때문이다.
- CPU 는 기본적으로 캐시에 먼저 연산을 수행하고 쓰기 작업일 경우 비동기로 메인 메모리에 기록된다.
- 캐시에서 데이터를 읽는 것이 메인 메모리보다 훨씬 빠르기 때문에 최신 CPU 에서는 좋은 성능을 위해 필수적이다.
- 데이터 복사본이 여러개 생기면 (하나는 메인 메모리 다른 데이터는 CPU 캐시) 복사본은 비동기로 갱신되므로 선형성이 손실된다.

왜 이런 트레이드 오프를 만들까 ? 
- CAP 정리는 말이 안된다. 한 컴퓨터 안에서 CPU 코어 하나가 다른 부분과 연결이 끊겼을 때 정상적으로 동작하기를 기대하지 않기 때문이다.
- 선형성을 제거한 이유는 **내결함성이 아니라 성능** 이다.

선현성을 보장하지 않는 여러 분산 데이터베이스도 마찬가지이다.<br/>
분산 데이터베이스들은 내결함성이 아닌 성능을 향상 시키기 위해서 선형성을 포기했다.<br/>
선형성은 네트워크 결함과 관련 없이 항상 느리다.<br/>
<br/>
좀 더 효율적인 선형 저장소 구현은 없을까?<br/>
- 질문의 답은 "없다" 이다
- 아티야(Attiya)와 웰치(Welch)는 선형성을 원하면 읽기/쓰기 요청의 응답 시간이 적어도 네트워크 지연의 불확실성에 비례해야 함을 증명했다.
- 대부분의 네트워크는 지연 변동이 매우 심하기 때문에(281p "타임아웃과 기약 없는 지연") 선형성 읽기/쓰기 요청에 응답시간은 필연적으로 높아진다.
- 선형성을 제공하는 빠른 알고리즘은 없지만 완화된 일관성 모델은 더 빠를 수 있다.

12 장에서는 정확성을 희생하지 않고 선형성을 회피하는 방법을 설명한다.

## 순서화 보장 
앞에서 선형성 레지스터는 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 어느 시점에 원자적 효과가 나타는 것처럼 보인다고 했다.<br/>
이 정의는 연산들이 어떤 잘 정의된 순서대로 실행된다는 것을 암시한다.<br/>

