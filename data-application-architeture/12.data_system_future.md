# 데이터 시스템의 미래 

지금까지는 현재 존재하는 것을 설명하는데 할애 했다면 이번 장은 미래에는 **어떻게 돼야 하는지** 를 설명한다.<br/>
이 책의 목적은 어플리케이션과 시스템을 **신뢰할 수 있고 확장가능하며 유지보수 하기 쉽게** 만드는 방법을 탐구하는 것이다.<br/>
예를들어 신뢰성에 도움을 주는 내결함성 알고리즘, 확장성을 위한 파티셔닝, 유지보수를 위한 진화와 추상화 메커니즘을 이전에 설명했다.<br/>
이번 장에서는 그것들을 기반으로 미래를 고찰한다.<br/>

## 데이터 통합 
이 책에서 어떤 문제에 대한 몇 가지 해결책을 놓고 장단점, 트레이드 오프에 대해서 설명했다.
- 3장 저장소 엔진: 로그 구조화 저장소, B 트리, 컬럼 지향 저장소 
- 5장 복제: 단일 리더, 복수 리더, 리더 없는 접근법 

문제가 주어졌을 때 우리는 특정 접근법 하나를 채택한다.<br/>
선택의 폭이 넓을 경우, 우리는 소프트웨어 제품과 그 제품이 어울리는 환경 사이의 대응관계를 파악해야 한다.<br/>
밴더는 소프트웨어가 적합하지 않는 작업부하에 대해 말하는 것을 꺼린다.<br/>
이전 장에서 트레이드 오프에 대해서 설명했으니 참고하기 바란다.<br/>
<br/>
그러나 대응 관계를 완벽히 파악하더라도 복잡한 어플리케이션에서는 데이터를 여러 방법으로 사용하며, <br/>
그에 적합한 소프트웨어 1개를 매칭하기는 어렵다.<br/>
따라서 여러 다른 소프트웨어를 함께 사용하게 된다.<br/>

### 파생 데이터에 특화된 도구의 결합 
OLTP 데이터베이스와 전문 검색 색인을 통합하는 요구는 일발적이다.<br/>
포스트그레스큐엘 같은 데이터베이스는 전문 색인 기능이 포함되어 있어 간단한 어플리케이션을 만들기에는 적합하지만<br/>
더 복잡한 검색 기능을 지원하기 위해서는 새로운 도구가 필요하다.<br/>
반대로 검색 색인은 지속성 있는 레코드 시스템으로는 일반적으로 적합하지 않다.<br/>
<br/>
448p "시스템 동기화 유지하기" 에서 설명했지만 데이터를 다른 방식으로 표현하는 시스템 수가 늘어날수록 통합하기가 더욱 어렵다.<br/>
<br/>
놀랍게도 "내가 해봤는데 99% 는 X만 있으면 돼" or "99% 는 X가 전혀 필요없어" 라는 얘기를 듣곤한다.<br/>
이런 말은 실제로 유용성 보다는 화자의 경험에 대해 얘기하는 것이라고 생각한다.<br/>
따라서 데이터 통합은 조직의 전체 데이터 플로를 고려할 때 비로소 명확해진다.

### 데이터플로에 대한 추론 
데이터 사본을 여러 저장소 시스템에 유지해야 할 때 **입력과 출력** 을 분명히 할 필요가 있다.
- 어디서 데이터를 처음 기록하는지 
- 어떤 표현형이 어디서 파생되었는지 
- 데이터를 적절한 장소에 형태에 맞게 넣는지 

등에 대해서 충분히 고려해야 한다.<br/>
<br/>
그림 11-4 에서 설명한 것 처럼 어플리케이션에서 직접 데이터베이스, 검색 색인에 기록한다면 <br/>
두 클라이언트가 동시에 보낸 쓰기가 충돌을 일으켜 두 저장소 시스템에서 서로 다른 순서로 데이터를 처리한다.<br/>
이 경우 데이터베이스와 검색 색인이 모두 쓰기의 순서를 결정하는 "책임" 이 없기 때문에 모순된 결정을 내리고 불일치가 발생한다.<br/>
<br/>
모든 쓰기의 순서를 결정하는 단일 시스템이 있다면 쓰기를 같은 순서로 처리해 파생하기가 더 쉬워진다.<br/>
이 방법은 345p "전체 순서 브로드캐스트" 에서 설명한 상태 기계 복제 접근법의 응용이다.<br/>
<br/>
파생 데이터 시스템은 이벤트 로그를 기반으로 갱신하면 결정적이고 멱등성을 지녀 결함에서 복구하기가 쉬워진다.

### 파생 데이터 대 분산 트랜잭션 
서로 다른 데이터 시스템 간 일관성을 유지하는 방법은 351p "원자적 커밋과 2단계 커밋" 에서 설명한 분산트랜잭션이다.<br/>
파생 데이터 시스템은 분산 트랜잭션과 비교해보면 어떨까?<br/>
<br/>
파생 데이터와 분산 트랜잭션은 다른 방식으로 유사한 목표를 달성한다.
- 분산 트랜잭션은 상호 배타적인 잠금을 사용해 쓰기 순서를 결정 (256p "2단계 잠금")
- 분산 트랜잭션은 원자적 커밋을 사용해 변경 효과가 한번만 나타나도록 보장 
- CDC 와 이벤트 소싱은 순서를 결정하는데 로그를 사용한다 
- 로그 기반 시스템은 결정적 제시도와 멱등성을 기반으로 동작 

두 시스템은 큰 차이점이 있다.
- 트랜잭션 시스템은 선형성을 지원 (자신이 쓴 내용 읽기 같은 유용한 기능을 보장) 
- 파생 데이터 시스템은 비동기로 갱신되기 때문에 동시간 갱신 보장을 하지 않음 

<br/>
분산 트랜잭션 비용을 지불할 만한 제한된 환경에서 잘 사용해왔지만<br/>
내 생각으로는 XA 는 결함 대응에 취약하고 성능면에서 나쁘다(357p "현실의 분산 트랜잭션")<br/>
나는 분산 트랜잭션에 더 적합한 프로토콜을 만들 수 있다고 믿는다.<br/>
그러나 그런 프로토콜이 기존 도구와 통합되면서 널리 채택되기는 근시일 내에는 어렵다.<br/>
나는 로그 기반 파생 데이터가 이종 데이터 시스템을 통합하는 가장 좋은 접근법이라고 생각한다.<br/>
다만 선형성은 유용한 기능이다. 따라서 최종적 일관성을 어떻게 다루는지에 대한 지침이 필요하다.<br/>

### 전체 순서화의 제약 
작은 시스템에서 이벤트 로그의 전체 순서를 보장하는 것은 가능하지만 <br/>
시스템이 커지면서 복잡한 작업 부하가 발생함에 따라서 한계가 드러나기 시작한다.
- 전체 순서가 정해진 로그를 구축할 때 순서를 결정하려면 모든 이벤트가 **단일 리더 노드** 를 통해야 한다 
  - 그러나 단일 노드가 처리 할 수 있는 양을 넘어선다면 파티셔닝이 필요하고 순서를 결정하는 것은 어렵다 
- 서버가 **지역적으로 분산된** 여러 데이터 센터에 구성되었다면 각 데이터센터에 리더를 둔다 
  - 데이터 센터를 거쳐 동기식 코디네이션 하는 것은 비효율적이기 때문이다 
  - 즉 서로 다른 데이터 센터에서 나온 이벤트는 순서가 정해지지 않았다는 의미이다
- 어플리케이션을 마이크로서비스로 배포한다고 하면 각 서비스는 지속적인 상태 정보를 독립적인 단위로 배포하고 상태를 공유하지 않는다 
  - 따라서 두 이벤트가 서로 다른 서비스에서 발생했다면 순서가 없다 
- 클라이언트 측에서 상태를 유지하는 서비스는 이벤트의 순서가 클라이언트와 서버가 다를 확률이 높다 

이벤트의 순서를 결정하는 것을 공식적인 용어로 **전체 순서 브로드캐스트** 라고 한다.<br/>
전체 순서 브로드캐스트는 합의와 동등하다.(363p "합의 알고리즘과 전체 순서 브로드캐스트")<br/>
합의 알고리즘은 기본적으로 단일 노드에서 전체 이벤트 처리가 가능하다는 가정이 있다.<br/>
여러 노드에 걸친 전체 이벤트 처리를 위한 합의 알고리즘 설계는 아직 해결되지 않은 연구과제다.<br/>


### 인과성 획들을 위한 이벤트 순서화 
이벤트 간 인과성이 없는 경우 전체 순서가 정해지지 않아도 큰 문제가 아니다.<br/>
임의로 순서를 정할 수 있기 때문이다.<br/>
그러나 때로는 인과성이 미묘한 방식으로 발생하기도 한다(337p "순서와와 인과성")<br/>
<br/>
예를들어 SNS 에서 관계를 맺은 두 사용자가 방금 관계를 끊었다고 하자.<br/>
사용자 한명이 친구 관계를 삭제하고 남은 친구들에게 삭제한 친구에 대해 불평하는 메시지를 보냈다.<br/>
이 사용자의 의도는 친구 관계를 끊은 사용자가 이 메시지를 보지 않기를 원했다.<br/>
<br/>
그러나 친구 상태를 저장하는 곳과 메시지를 저장하는 곳이 다른 시스템에서는 **친구 끊기** 이벤트와 **메시지 보내기** 이벤트 사이의 의존성이 없다.<br/>
인과성이 없다면 메시지 보내기 이벤트가 먼저 발송되어서 잘못된 친구에게 메시지가 전송될 수 있다.<br/>
이 예제에서 알림은 결과적으로 메시지와 친구 관계를 조인한 것으로 473p "조인의 시간 의존성" 과 관련이 있다.<br/>
이 문제를 간단히 해결하는 방법은 없고 해결을 위한 출발점 몇 가지를 보자
- 논리적 타임스탬프를 사용하면 코디네이션 없이 전체 순서화를 지원(341p "일련번호 순서화") 할 수 있지만 여전히 수신자가 잘못된 순서로 전달된 이벤트를 처리해야 하고 추가로 메타 데이터를 전달해야 한다
- 사용자가 결정을 내리기 전에 사용자가 본 시스템 상태를 기록하는 이벤트를 로깅할 수 있고 해당 이벤트에 고유 식별자를 부여할 수 있다면 이벤트 식별자를 참조해서 인과적 의존성을 표현할 수 있다 
- 충돌 해소 알고리즘(175p "자동 충돌 해소")은 예상치 못한 순서로 전송된 이벤트를 처리하는데 도움을 준다. 이 알고리즘은 활동에 외부 부수효과(사용자에게 알림을 보내는 작업 등) 가 있다면 도움이 되지 않는다 

### 일괄 처리와 스트림 처리 
나는 데이터 통합의 목표는 데이터를 올바른 장소에 올바른 형태로 두는 것이라고 생각한다.<br/>
그렇게 하기 위해서 입력을 적절한 형태로 바꾸거나 필터링하여 적절한 출력을 만들어야 한다.<br/>
일괄 처리와 스트림 처리의 출력은 파생 데이터 셋이다. <br/>
10장, 11장에서 설명한 것 처럼 일괄 처리와 스트림 터리는 여러 공통 원리가 있다.<br/>
주요 차이점은 스트림 처리는 끝이 없는 데이터셋 상에서 운영되는 반면 일괄 처리는 유한한 크기의 입력을 사용하는 것이다.<br/>
- 스파크는 일괄 처리 엔진 상에서는 스트림을 처리하는데 스트림을 **마이크로 일괄처리** 단위로 나누어 처리한다
- 아파치 플링크는 스트림 처리 엔진 상에서 일괄 처리를 수행한다 

### 파생 상태 유지 
일괄 처리는 함수형 프로그래밍 언어를 사용하지 않아도 함수형 특징을 가진다.<br/>
일괄 처리는 결정적이고 출력이 입력에만 의존하며 다른 부수효과가 없는 순수 함수를 장려하며 입력을 불변으로 간주하고 출력은 추가 전용으로만 사용한다.<br/>
입력과 출력을 잘 정의한 결정적 함수의 원리는 내결함성에 도움이 될 뿐 아니라(475p "멱등성") 데이터플로 추론을 단순화한다.<br/>
데이터 파이프라인은 함수형 어플리케이션 코드를 통해 한 시스템의 상태 변화를 밀어 넣고 그 결과를 파생 시스템에 적용한다.<br/>
파생 데이터 시스템은 관계형 데이터베이스가 색인할 테이블에 보조색인을 갱신하는 것처럼 동기식으로 운영할 수 있다.<br/>
하지만 비동기 방식을 사용하면 이벤트 로그 기반 시스템을 훨씬 견고하게 만든다.<br/>
비동기 방식은 결함이 국소적으로 남아있게 해준다.<br/>
반면 분산 트랜잭션은 일부가 실패하면 어보트하기 때문에 나머지 시스템으로 실패가 확산되어 실패가 증폭되는 경향이 있다.(360p "분산 트랜잭션의 제약")<br/>

### 어플리케이션 발전을 위한 데이터 재처리
파생 데이터를 유지할 때 일괄 처리와 스트림 처리는 모두 유용하다.<br/>
스트림 처리를 이용하면 입력의 변화를 빠르게 파생 뷰에 반영할 수 있다.<br/>
일괄 처리는 누적된 상당한 양의 과거 데이터를 재처리해 기존 데이터셋을 반영한 새 파생 뷰를 만들수 있다.<br/>
<br/>
기존 데이터를 재처리하는 것은 시스템을 유지보수하기 좋은 메커니즘으로 기능 추가와 변경된 요구사항에 대응할 수 있다.<br/>
재처리를 하지 않고 스크미를 변경하는 것은 선택된 필드를 추가하는 것과 같은 간단한 작업으로 제한된다.(39p "문서 모델에서의 스키마 유연성")<br/>
파생 뷰를 사용하면 점진적 발전이 가능하다.<br/>
데이터를 재처리함으로써 이전 뷰와 새로운 뷰을 함께 유지하고 기존 뷰를 제공하면서도 일부 사용자에게 새로운 뷰를 제공할 수 있다.<br/>
점진적 이전의 장점은 처리의 특정 단계가 잘못되었을 떄 쉽게 이전으로 돌릴 수 있다는 점이다.

### 람다 아키텍처
람다 아키텍처는 일괄 처리를 과거 데이터를 재처리 하는데 사용하고 스트림 처리를 최근 갱신 데이터를 처리하는데 사용하는 방법이다.<br/>
핵심 아이디어는 입력 데이터를 불변 이벤트로서 증가하기만 하는 데이터 셋에 추가하는 방식으로 기록해야 한다는 것으로 이벤트 소싱과 유사하다.<br/>
람다 아키텍처는 두 개의 다른 시스템을 병행해서 운용하기를 제안한다.<br/>
- 하둡 맵리듀스 같은 일괄 처리 시스템과 스톰 같은 분리된 스트림 처리 시스템을 함께 운용

<br/>
람다 아키텍처 접근법
- 스트림 처리자는 이벤트를 소비해 근사 갱신을 뷰에 빠르게 반영한다.
- 이후 일괄 처리자가 같은 이벤트 집합을 소비해 정확한 버전의 파생 뷰에 반영한다.

람다 아키텍쳐의 설계 배경은 일괄처리는 간단해서 버그가 생길 가능성이 적은 반면 스트림 처리는 신뢰성이 떨어지고 내결함성을 확보하기 어렵다는 것이다.<br/>
람다 아키텍쳐는 데이터 시스템 설계를 향상 시키는 데 영향을 준 아이디어였다.<br/>
불변 이벤트 스트림에 대한 뷰를 파생하고 필요할 때 이벤트를 재처리하는 원리를 보급했다.<br/>
하지만 나는 람다 아키텍쳐에는 실질적 문제가 몇 가지 있다고 생각한다.
- 일괄 처리와 스트림 처리 양쪽에서 같은 로직을 유재히야 하는 상당한 노력이 필요하다.(디버깅, 튜닝, 운영상 복잡성)
- 스트림 파이프라인과 일괄 처리 파이프라인은 다른 출력을 생산하기 때문에 사용자 요청에 따라 출력을 병합해야 한다(조인이나 세션화 같은 복잡한 연산이 필요한 뷰는 출력이 시계열이 아니라면 어렵다)
- 과거 데이터를 재처리 할 수 있는 점은 훌륭하지만 대용량 데이터 셋에서 그 일을 자주 수행한다면 그 비용도 적지 않다.

### 일괄 처리와 스트림 처리의 통합
최근에는 같은 시스템에서 일괄 처리 연산과 스트림 연산을 모두 구현함으로써 람다 아키텍처의 단점을 빼고 장점만 취할 수 있게 하는 작업이 진행되고 있다.<br/>
한 시스템에서 일괄 처리와 스트림 처리를 통합하려만 아래 기능들이 필요하다
- 최근 이벤트 스트림을 다루는 처리 엔진에서 과거 이벤트를 재생하는 능력 (메시지 브로커는 메시지를 재생하는 능력)
- 스트림 처리자에서 사용되는 정확히 한 번 시맨틱 (결함이 발생해도 결함이 없었던 것처럼 동일한 출력을 보장)
- 이벤트 시간 기준으로 윈도우를 처리하는 도구 

## 데이터베이스 언번들링 
데이터베이스는 특정 데이터 모델의 레코드로 데이터를 저장한다.<br/>
반면 OS는 데이터를 파일로서 파일 시스템에 저장한다.<br/>
양쪽 모두 "정보 관리" 시스템이다. 10장에서 설명한 것 처럼 하둡 생태계는 유닉스의 분산 버전과 비슷하다.<br/>
유닉스와 관계형 데이터베이스는 정보 관리 문제는 다른 철학으로 접근했다.
- 유닉스는 노리적이지만 저순준인 하드웨어 추상화를 프로그래머에게 제공하는 목적 
- 관계형 데이터베이스는 디스크 상의 자료구조, 동시성, 장애 복구 등 복잡성을 감추는 고수준의 추상화를 프로그래머에게 제공하려고 했다 

어느 것이 더 좋을까 ?<br/>
당연하게도 무엇을 원하는지에 따라 다르다.<br/>
유닉스와 관계형 데이터베이스 사이의 긴장감은 수 세기 동안 지속됐고 해결되지 않았다.<br/>
이를테면 나는 NoSQL 을 유닉스의 저수준 추상화 접근법을 분산 OLTP 데이터 저장소 분야로 적용하려는 움직임으로 해석한다.<br/>

### 데이터 저장소 기술 구성하기 
이 책에서 데이터베이스가 제공하는 다양한 기능을 설명하고 어떻게 동작하는지를 설명했다.
- 보조 색인은 필드 값을 기반으로 레코드를 효율적으로 검색할 수 있는 기능 
- 구체화 뷰는 질의 결과를 미리 연산한 캐시의 일종
- 복제 로그는 데이터의 복사본을 다른 노드에 최신 상태로 유지하는 기능 
- 전문 검색 색인은 텍스트에서 키워드 검색을 가능하게 하는 기능 

10장, 11장에서도 비슷한 주제가 등장했다.<br/>
407p "일괄 처리 워크플로의 출력" 에서 전문 검색 색인을 구축하는 방법, 464p "구체화 뷰 유지하기" 에서 구체화 뷰를 유지하는 방법, 405p "변경 데이터 캡처" 에서 DB 변경 사항을 파생 데이터 시스템으로 복제하는 방법
<br/>
데이터베이스에 내장된 기능과 일괄 처리와 스트림 처리로 구축하는 파생 시스템 사이에는 유사점이 있다.

### 색인 생성하기
관계형 데이터베이스에 색인을 생성하기 위해 ```CREATE INDEX``` 를 실행 했을 때 무슨 일이 일어나는지 생각해보자.
- 테이블의 일관된 스냅숏을 사용해 스캔하고
- 색일할 필드 값을 모두 골라 정렬하고 색인에 기록한다
- 그 다음에는 일관된 스냅숏을 만든 이후에 실행된 쓰기의 백로그를 처리한다 
- 색인 생성을 완료하면 데이터베이스는 트랜잭션이 테이블에 쓸 때마다 꾸준히 색인에 반영해야 한다 

이 과정은 새 팔로워 복제본을 구축하는 과정과 대단히 비슷하다.(157p "새로운 팔로워 설정")<br/>
스트림 시스템에서 변경 데이터 캡처의 예비 과정과도 상당히 유사하다.(452p "초기 스냅숏")<br/>

### 모든 것의 메타 데이터베이스 
이런 관점에서 내게는 조직의 데이터 플로가 거대한 데이터베이스처럼 보이기 시작했다.<br/>
데이터를 특정 형태에서 다른 장소에 있는 다른 형태로 바뀌 전송할 때마다 색인이나 구체화 뷰를 최신으로 유지하는 데이터베이스의 하위 시스템과 동일하게 동작한다.<br/>
유사한 관점으로 일괄 처리와 스트림 처리는 트리거와 스토어드 프로시저 그리고 구체화 뷰 유지 루틴을 정교하게 구현한 것과 같다.<br/>
파생 데이터 시스템이 만든 파생 데이터는 마치 다양한 색인 유형과 비슷하다.<br/>
파생 데이터 시스템 아키텍처가 등장하면서 통합된 데이터베이스로 기능을 구현하지 않고 여러 장비에서 실행되고 여러 팀에서 관리하는 다양한 소프트웨어를 사용한다.<br/>
<br/>
이런 개발 방법은 미래에 우리를 어디로 데려갈까?<br/>
나는 서로 다른 처리 도구를 사용하지만 하나의 응집된 시스템으로 구성할 수 있는 2가지 길이 있다고 생각힌다.
- 연합 데이터베이스: 읽기를 통합 
  - 연합 데이터베이스 or 폴리스토어 라고 알려진 접근법은 엄청나게 많은 하단 저장소 엔진과 처리 메서드를 통합해 질의하는 인터페이스를 제공한다
