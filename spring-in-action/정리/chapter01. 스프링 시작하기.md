# 스프링이란?

- 스프링은 스프링 애플리케이션 컨텍스트(Spring application context)라는 컨테이너(Container)를 제공하는데, 이것은 애플리케이션 컴포넌트들을 생성하고 관리한다.
- 애플리케이션 컴포넌트(Component) 또는 빈(Bean)들은 스프링 애플리케이션 컨텍스트 내부에서 서로 연결되어 완전한 애플리케이션을 만든다.
- 빈의 상호 연결은 의존성 주입(Dependency Injection, DI)이라고 알려진 패턴을 기반으로 수행된다.
- 애플리케이션 컴포넌트에서 의존(사용)하는 다른 빈의 생성과 관리를 저체적으로 하는 대신 별도의 개체(컨테이너)가 해주며, 이 개체에서는 모든 컴포넌트를 생성, 관리하고 해당 컴포넌트를 필요로 하는 빈에 주입(연결)한다.

![chapter01-01](image/chapter01-01.png '애플리케이션 컴포넌트는 스프링 애플리케이션 컨텍스트에 의해 관리되고 상호 주입된다.')

- 지금까지의 스프링 버전에서는 컴포넌트 및 다른 컴포넌트와의 관계를 나타내는 하나 이상의 XML 파일을 사용해서 빈을 상호 연결하도록 스프링 애플리케이션 컨텍스트에 알려주었다.

```xml
<beans>
    <bean id="inventoryService"
        class="com.example.InventoryService" />
    
    <bean id="productService"
        class="com.example.ProductService">
        <constructor-arg ref="inventoryService" />
    </bean>
</beans>
```

- 최신 버전의 스프링에서는 자바 기반의 구성(Configuration)이 더 많이 사용된다.

```java
@Configuration
public class ServiceConfiguration {
	@Bean
	public InventoryService inventoryService() {
		return new InventoryService();
	}
	@Bean
	public ProductService productService() {
		return new ProductService(inventoryService());
	}
}
```

- 여기서 @Configuration 애노테이션(annotation)은 이것이 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 구성 클래스라는 것을 스프링에게 알려준다.
- 구성 클래스의 메서드에는 @Bean 애노테이션이 지정되어 있으며, 이것은 각 메서드에서 반환되는 객체가 애플리케이션 컨텍스트의 빈으로 추가되어야 한다는 것을 나타낸다.
    - 기본적으로 각 빈의 ID가 해당 빈을 정의하는 메서드의 이름과 동일하다.
- XML 기반 구성에 비해 자바 기반 구성은 더 강화된 타입 안전과 향상된 리팩토링(refactoring) 기능을 포함해서 몇 가지 장점을 제공한다.
    - 그러나 스프링은 자동으로 컴포넌트들을 구성할 수 있는 자동-구성 기능이 있어서 XML 구성이나 자바 구성이 없어도 된다.
    - 따라서 자동-구성을 할 수 없을 경우에만 필요하다.
- 자동-구성은 자동 연결(autowiring)과 컴포넌트 검색(component scan)이라는 스프링 기법을 기반으로 한다.
    - 컴포넌트 검색을 사용하여 스프링은 자동으로 애플리케이션의 classpath에 지정된 컴포넌트를 찾은 후 스프링 애플리케이션 컨텍스트의 빈으로 생성할 수 있다.
    - 또한, 스프링은 자동 연결을 사용하여 의존 관계가 있는 컴포넌트를 자동으로 다른 빈에 주입(연결)한다.
- 스프링 부트는 생산성 향상을 제공하는 스프링 프레임워크의 확장이며, 향상된 자동-구성(autoconfiguration) 기능에 의해 환경 변수인 classpath를 기준으로 어떤 컴포넌트가 구성되고 연결되어야 하는지 알 수 있다.
- 자동-구성을 보여주는 예제 코드를 보여줄 수 없다.
    - 우리가 코드를 작성하지 않아도 컴포넌트가 활성화되고 자동-구성이 작동하기 때문이다.
- 스프링 부트의 자동-구성은 애플리케이션을 빌드하는 데 필요한 별도의 구성 코드(XML이나 자바의 어떤 것이든)를 현격히 줄여준다.
- 이 책에서는 될 수 있는 대로 스프링 부트를 많이 사용하고 별도의 구성 파일은 꼭 필요할 때만 사용할 것이다.

# 스프링 애플리케이션 초기 설정하기

- 스프링 Initializr(이니셜라이저)를 사용해서 우리 애플리케이션을 초기 설정할 것이다.
- 스프링 Initializr는 REST API를 사용하는 브라우저 기반의 웹 애플리케이션이며 , 우리가 원하는 기능을 구현할 수 있는 스프링 프로젝트의 구조를 생성해 준다.
- 스프링 Initializr를 사용하는 방법은 다음과 같이 여러 가지가 있다.
    - [https://start.spring.io](https://start.spring.io)의 웹 애플리케이션에서
    - 명령행에서 curl 명령을 사용해서
    - 명령행에서 스프링 부트 CLI(Command-Line Interface)를 사용해서
    - Spring Tool Suite IDE를 사용해서 새로운 프로젝트를 생성할 때
    - IntelliJ IDEA IDE를 사용해서 새로운 프로젝트를 생성할 때
    - NetBeans IDE를 사용해서 새로운 프로젝트를 생성할 때

## 스프링 프로젝트 구조 살펴보기

![chapter01-02](image/chapter01-02.png '초기의 스프링 프로젝트 구조')

- 프로젝트 구조
    - mvnw와 mvnw.cmd : 이 파일들은 메이븐 래퍼 스크립트다. 메이븐이 각자 컴퓨터에 설치되어 있지 않더라도 이 스크립트를 사용하여 프로젝트를 빌드할 수 있다.
    - pom.xml :  이것은 메이븐 빌드 명세(우리 프로젝트를 빌드할 때 필요한 정보)를 지정한 파일이다. 이 파일의 내용은 잠시 후에 더 자세히 살펴볼 것이다.
    - TacoCloudApplication.java : 이것은 스프링 부트 메인 클래스이며, 잠시 후에 더 살펴볼 것이다.
    - application.properties : 처음에는 이 파일의 내용이 없지만, 우리가 구성 속성을 지정할 수 있다. 구성 속성의 자세한 내용은 5장에서 알아볼 예정이다.
    - static : 이것은 브라우저에 제공할 정적인 콘텐츠(이미지, 스타일시트, 자바스크립트 등)를 둘 수 있는 폴더다. 처음에는 비어 있다.
    - templates : 이것은 브라우저에 콘텐츠를 보여주는 템플릿 파일을 두는 폴더다. 처음에는 비어 있지만, 여기서 조만간 Thymeleaf 템플릿을 추가할 것이다.
    - TacoCloudApplicationTests.java : 이것은 스프링 애플리케이션이 성공적으로 로드되는지 확인하는 간단한 테스트 클래스다. 우리 애플리케이션을 개발하는 동안 더 많은 테스트를 추가할 것이다.

### 빌드 명세 살펴보기

- pom.xml의 내용에서
    - 제일 먼저 눈여겨볼 것은 `<parent>`요소의 `<version>`이다. 이 태그에는 우리 프로젝트가 부모 POM(Project Object Model)으로 spring-boot-starter-parent를 갖는다는 것을 지정한다.
        - 이 부모 POM은 스프링 프로젝트에 흔히 사용되는 여러 라이브러리의 의존성 관리를 제공한다.
        - 따라서 이런 라이브러리들의 경우는 버전을 지정할 필요가 없다.
    - 의존성은 `<dependencies>` 요소에 정의되며, 프로젝트를 생성할 때 지정한 의존성이 `<dependency>` 요소로 지정된다.
        - spring-boot-starter-test는 우리가 테스트를 작성할 것에 대비하여 스프링 Initializr가 자동으로 추가해 준다.
    - `<artifactId>`에 starter 단어를 포함하는 의존들이 있다.
        - 이것은 스프링 부트 스타터(starter) 의존성을 나타낸다.
        - 이 의존성 항목들은 자체적으로 라이브러리 코드를 갖지 않고 다른 라이브러리의 것을 사용한다.
        - 스타터 의존성은 다음 세 가지 장점이 있다.
            - 우리가 필요로 하는 모든 라이브러리의 의존성을 선언하지 않아도 되므로 빌드 파일이 훨씬 더 작아지고 관리하기 쉬워진다.
            - 라이브러리 이름이 아닌 기능의 관점으로 의존성을 생각할 수 있다. 따라서 만일 웹 애플리케이션을 개발한다면 웹 애플리케이션을 작성할 수 있게 해주는 라이브러리들을 일일이 지정하는 대신에 여기처럼 웹 스타터 의존성만 추가하면 된다.
            - 라이브러리들의 버전을 걱정하지 않아도 된다. 스프링 부트에 포함되는 라이브러리들의 버전은 호환이 보장되므로 사용하려는 스프링 부트의 버전만 신경 쓰면 된다.
        - 빌드 명세를 정의한 pom.xml 파일의 제일 끝에는 스프링 부트 플러그인이 지정된다. 이 플러그인의 중요 기능은 다음과 같다.
            - 메이븐을 사용하는 애플리케이션을 실행할 수 있게 해준다.
            - 의존성에 지정된 모든 라이브러리가 실행 가능 JAR 파일에 포함되어 있는지 그리고 런타임 시에 classpath에서 찾을 수 있는지 확인한다.
            - 실행 가능 JAR 파일의 메인 클래스로 부트스트랩 클래스(여기서는 TacoCloudApplication)를 나타내는 매니페스트 파일을 JAR 파일에 생성한다.

### 애플리케이션의 부트스트랩(구동)

- 실행 가능 JAR 파일에서 애플리케이션을 실행하므로 제일 먼저 시작되는 부트스트랩 클래스가 있어야 한다.
- 또한, 애플리케이션을 부트스트랩하기 위한 최소한의 스프링 구성도 있어야 한다.

```java
package tacos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // <- 스프링 부트 애플리케이션
public class TacoCloudApplication {
	public static void main(String[] args) {
		SpringApplication.run(TacoCloudApplication.class, args); // 애플리케이션을 실행한다.
	}
}
```

- @SpringBootApplication 애노테이션은 이 코드가 스프링 부트 애플리케이션임을 나타낸다.
- @SpringBootApplication 애노테이션은 다음 세 개의 애노테이션이 결합한 것이다.
    - @SpringBootConfiguration : 현재 클래스(TacoCloudApplication)를 구성 클래스로 지정한다. 필요하다면 자바 기반의 스프링 프레임워크 구성을 현재 클래스에 추가할 수 있다. 실제로는 이 애노테이션이 @Configuration 애노테이션의 특화된 형태다.
    - @EnableAutoConfiguration : 스프링 부트 자동-구성을 활성화한다. 지금은 우리가 필요로 하는 컴포넌트들을 자동으로 구성하도록 스프링 부트에 알려준다는 것만 알아 두자.
    - @ComponentScan : 컴포넌트 검색을 활성화한다. 이것은 @Component, @Controller, @Service 등의 애노테이션과 함께 클래스를 선언할 수 있게 해준다. 그러면 스프링은 자동으로 그런 클래스를 찾아 스프링 애플리케이션 컨텍스트에 컴포넌트를 등록한다.
- TacoCloudApplication의 또 다른 중요한 부분은 main() 메서드다.
    - 이것은 JAR 파일이 실행될 때 호출되어 실행되는 메서드다.
    - main() 메서드는 실제 애플리케이션을 시작시키고 스프링 애플리케이션 컨텍스트를 생성하는 SpringApplication 클래스의 run() 메서드를 호출한다.
- 부트스트랩 클래스의 내용은 변경할 필요가 없을 것이다.
- 대부분의 애플리케이션에서는 자동-구성되지 않는 것들을 고려하여 별도의 구성 클래스 하나를 생성하는 것이 좋다.

### 애플리케이션 테스트하기

```java
package tacos;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TacoCloudApplicationTests {
	@Test
	void contextLoads() {
	}
}
```

- 테스트 클래스인 TacoCloudApplicationTests의 코드는 간단하다.
- 이 클래스에는 하나의 테스트 메서드가 있으며, 실행 코드는 없다.
- 그렇더라도 이 테스트 클래스는 스프링 애플리케이션 컨텍스트가 성공적으로 로드될 수 있는지 확인하는 기본적인 검사를 수행한다.
    - 따라서 만일 스프링 애플리케이션 컨텍스트의 생성을 저해하는 코드가 있다면 이 테스트가 실패하게 되므로 문제점을 찾아 해결할 수 있다.
- @SpringBootTest는 스프링 부트 기능으로 테스트를 시작하는 것을 JUnit에 알려준다.
    - 일단 지금은 main() 메서드의 SpringApplication.run() 호출에 부합되는 테스트 클래스를 나타낸다는 정도로 알아 두자.

# 스프링 애플리케이션 작성하기

- 타코 클라우드 애플리케이션에 추가할 첫 번째 기능은 홈페이지(homepage)이며, 다음의 두 가지 코드를 생성한다.
    - 홈페이지의 웹 요청(request)을 처리하는 컨트롤러(controller) 클래스
    - 홈페이지의 모습을 정의하는 뷰 템플릿

## 웹 요청 처리하기

- 스프링은 스프링 MVC라고 하는 강력한 웹 프레임워크를 가지고 있다.
- 스프링 MVC의 중심에는 컨트롤러가 있으며, 이것은 웹 요청과 응답을 처리하는 컴포넌트(또는 구성 요소)다.
- 웹 브라우저를 상대하는 애플리케이션의 경우에 컨트롤러는 선택적으로 모델 데이터를 채워서 응답하며, 브라우저에 반환되는 HTML을 생성하기 위해 해당 응답의 웹 요청을 뷰에 전달한다.

```java
package tacos;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller // <- 컨트롤러
public class HomeController {
	@GetMapping("/") // <- 루트 경로인 /의 웹 요청을 처리한다.
	public String home() {
		return "home"; // 뷰 이름을 반환한다.
	}
}
```

- @Controller 자체는 그리 많은 일을 하지 않는다.
    - 컴포넌트 검색 시에 HomeController 클래스가 컴포넌트로 식별되게 하는 것이 주 목적이기 때문이다.
    - 따라서 스프링의 컴포넌트 검색에서는 자동으로 HomeController 클래스를 찾은 후 스프링 애플리케이션 컨텍스트의 빈(bean)으로 HomeController의 인스턴스를 생성한다.
    - 다른 컴포넌트 애노테이션 말고 @Controller를 선택한 이유는 애플리케이션에서의 컴포넌트 역할을 더 잘 설명해 주기 때문이다.
- @GetMapping를 가진 home() 메서드는 루트 경로인 /의 HTTP GET 요청이 수신되면 이 메서드가 해당 요청을 처리한다.
    - 여기서는 home 값을 갖는 String만 반환하고 다른 일은 하지 않는다.
    - 이 값은 뷰의 논리적인 이름이다.
    - 뷰는 여러 방법으로 구현될 수 있지만, Thymeleaf가 우리의 classpath에 지정되어 있으므로 여기서는 Thymeleaf를 사용해서 뷰 템플릿을 정의할 수 있다.

### 왜 Thymeleaf를 사용할까?

- 필자가 다른 방법보다 Thymeleaf를 선호하기 때문이다.
- JSP를 스프링 부트와 같이 사용할 때는 몇 가지 고려할 것이 있다. 2장에서 살펴볼 것이다.
- 논리적인 뷰 이름(여기서는 home) 앞에 /templates/가 붙고 끝에는 .html이 추가된 것이 템플릿 경로와 파일 이름이 되므로 여기서는 /templates/home.html이 된다.
- 그리고 우리 프로젝트에는 /src/main/resources/templates/home.html로 템플릿이 저장되어야 한다.

### 뷰 정의하기

- 타코 클라우드 홈페이지 템플릿

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:th="http://www.thymeleaf.org">
	<head>
		<meta charset="EUC-KR">
		<title>Taco Cloud</title>
	</head>

	<body>
		<h1>Welcome to...</h1>
		<img th:src="@{/images/TacoCloud.png}" />
	</body>
</html>
```

- `<img>` 태그에서는 컨텍스트의 상대적인 경로에 위치하는 이미지를 참조하는 @{...} 표현식을 사용해서 Thymeleaf의 th:src 속성을 지정한다.
- 이미지와 같은 정적인 콘텐츠는 /src/main/resources/static 폴더에 위치해야 한다.

## 컨트롤러 테스트하기

```java
package tacos;

...

@WebMvcTest(HomeController.class) // <- HomeController의 웹 페이지 테스트
public class HomeControllerTest {
	@Autowired
	private MockMvc mockMvc; // MockMvc를 주입한다.

	@Test
	public void testHomePage() throws Exception {
		mockMvc.perform(get("/")) // GET /를 수행한다.
			.andExpect(status().isOk()) // HTTP 200이 되어야 한다.
			.andExpect(view().name("home")) // home 뷰가 있어야 한다.
			.andExpect(content().string( // 콘텐츠에 'Welcome to...'가 포함되어야 한다.
				containsString("Welcome to...")));
	}
}
```

- 여기서 HomeControllerTest는 @SpringBootTest 대신 @WebMvcTest 애노테이션을 사용한다.
    - 이것은 스프링 부트에서 제공하는 특별한 테스트 애노테이션이며, 스프링 MVC 애플리케이션의 형태로 테스트가 실행되도록 한다.
    - 또한 스프링 MVC를 테스트하기 위한 스프링 지원을 설정한다.
- 우리 테스트에서는 실제 서버를 시작하는 대신 스프링 MVC의 모의(mocking) 메커니즘을 사용해도 충분하므로 모의 테스트를 하기 위해 우리 테스트 클래스에 MockMvc 객체를 주입(연결)한다.
- 만일 MockMvc 객체가 루트 경로인 /의 HTTP GET 요청을 수행한 후, 세 가지 기대(Expect) 중 어느 하나라도 충족하지 않으면 테스트는 실패한다.

## 애플리케이션 빌드하고 실행하기

- 스프링 부트 애플리케이션에는 실행에 필요한 모든 것이 포함된다.
- 따라서 톰캣과 같은 애플리케이션 서버에 별도로 애플리케이션을 설치할 필요가 없다.

## 스프링 부트 DevTools 알아보기

- 개발 시점의 편리한 도구를 제공
    - 코드가 변경될 때 자동으로 애플리케이션을 다시 시작시킨다.
    - 브라우저로 전송되는 리소스(예를 들어, 템플릿, 자바스크립트, 스타일시트)가 변경될 때 잗종으로 브라우저를 새로고침한다.
    - 템플릿 캐시를 자동으로 비활성화한다.
    - 만일 H2 데이터베이스가 사용 중이라면 자동으로 H2 콘솔을 활성화한다.
- DevTools는 각종 IDE의 플러그인이 아니며, 특정 IDE를 사용해야 하는 것도 아니라는 것을 알아두자.
- 실제 운영에서는 스스로 비활성화된다.

### 자동으로 애플리케이션 다시 시작시키기

- DevTools를 사용 중일 때 애플리케이션은 JVM에서 두 개의 클래스 로더(loader)에 의해 로드된다.
- 변경이 감지되는 경우 DevTools는 우리 프로젝트 코드를 포함하는 클래스 로더만 다시 로드하고 스프링 애플리케이션 컨텍스트를 다시 시작시킨다.
    - 그러나 다른 클래스 로더와 JVM은 그대로 둔다.
    - 따라서 애플리케이션이 시작하는데 걸리는 시간을 조금이나마 단축해 준다.
- 이런 전략의 단점은 애플리케이션이 자동으로 다시 시작될 때 의존성 변경이 적용될 수 없다는 것이다.
    - 의존성 라이브러리를 포함하는 클래스 로더는 자동으로 다시 로드되지 않기 때문이다.
    - 따라서 빌드 명세(pom.xml 파일)에 의존성을 추가, 변경, 삭제할 때는 애플리케이션을 새로 시작해야만 그러한 변경의 효과가 나타날 수 있다.

### 자동으로 브라우저를 새로고침하고 템플릿 캐시를 비활성화하기

- 템플릿에서는 템플릿의 파싱(코드 분석) 결과를 캐시에 저장하고 사용하도록 구성된다.
    - 템플릿이 사용되는 모든 웹 요청마다 매번 다시 파싱되지 않게 하기 위해서다.
- 개발 시점에는 템플릿 캐싱이 그리 유용하지 않다.
    - 애플리케이션이 실행 중일 때 템플릿을 변경하고 브라우저를 새로고침하더라도 여전히 변경 전의 캐싱된 템플릿이 사용되므로 변경된 결과를 볼 수 없기 때문이다.
- DevTools가 사용될 때는 우리 애플리케이션과 함께 자동으로 LiveReload([http://livereload.com/](http://livereload.com/)) 서버를 활성화한다.
    - LiveReload 서버 자체는 그리 유용하지 않다.
    - 그러나 이 서버와 부합되는 LiveReload 브라우저 플러그인과 연결될 때는 브라우저에 전달되는 거의 모든 것(예를 들어, 템플릿, 이미지, 스타일시트, 자바스크립트 등)에 변경이 생길 때 브라우저가 자동으로 새로고침된다.

### H2 콘솔

- 3장에서 변경하겠지만, 우리 프로젝트는 아직 데이터베이스를 사용하지 않는다.
- 만일 개발용으로 H2 데이터베이스의 사용을 선택한다면, 웹 브라우저에서 사용할 수 있는 H2 콘솔도 DevTools가 자동으로 활성화해 준다.
- 따라서 웹 브라우저에서 [http://localhost:8080/h2-console](http://localhost:8080/h2-console)에 접근하면 애플리케이션에서 사용하는 데이터를 알 수 있다.

## 리뷰하기

- 지금까지 우리가 작성한 코드는 많지 않다.
- 이것이 스프링을 사용한 애플맄이션 개발의 커다란 장점이다.
    - 즉, 프레임워크의 요구를 만족시키기 위한 코드보다는 우리 애플리케이션의 요구를 충족하는 코드에 집중할 수 있다.

# 스프링 살펴보기

## 핵심 스프링 프레임워크

- 핵심 스프링 프레임워크는 스프링에 있는 모든 것의 기반이다.
- 이것은 핵심 컨테이너와 의존성 주입 프레임워크 외에 몇 가지 다른 기능도 제공한다.
- 그중 하나가 스프링의 웹프레임워크인 스프링 MVC다.
    - 즉, HTML이 아닌 출력을 생성하는 REST API를 만들 때도 스프링 MVC를 사용할 수 있다.
    - 스프링 MVC의 자세한 사용 방법은 6장에서 살펴볼 것이다.
- 핵심 스프링 프레임워크는 템플릿 기반의 JDBC 지원(JdbcTemplate)을 포함해서 기본적인 데이터 퍼시스턴스 지원도 제공한다.
    - 이 기능을 사용하는 방법은 3장에서 살펴볼 것이다.
- 스프링의 가장 최신 버전에서는 리액티브 프로그래밍 지원이 추가되었다.
    - 여기서는 스프링 MVC 개념의 스프링 WebFlux라는 새로운 리액티브 웹 프레임워크가 포함된다.
        - 스프링의 리액티브 프로그래밍 모델은 10, 11, 12장에서, 특히 스프링 WebFlux는 10장에서 알아볼 것이다.

## 스프링 부트

- 스타터 의존성과 자동-구성을 포함하는 스프링 부트의 여러 장점은 이미 알아보았다.
- 스타터 의존성과 자동-구성 외에도 스프링 부트는 다음의 다른 편리한 기능도 제공한다.
    - 액추에이터(Actuator)는 애플리케이션의 내부 작동을 런타임 시에 살펴볼 수 있는 기능을 제공하며, 여기에는 메트릭(metric), 스레드 덤프 정보, 애플리케이션의 상태, 애플리케이션에서 사용할 수 있는 환경 속성이 포함된다.
    - 환경 속성의 명세
    - 핵심 프레임워크에 추가되는 테스트 지원
- 스프링 부트 CLI(Command-Line Interface, 명령행 인터페이스)를 제공한다.
- 스프링 부트 CLI를 사용하면 애플리케이션 전체를 그루비 스크립트들로 작성하여 명령행에서 실행할 수 있다.

## 스프링 데이터

- 간단한 자바 인터페이스로 우리 애플리케이션의 데이터 리퍼지터리를 정의할 수 있다.
    - 이 때 데이터 저장하고 읽는 메서드를 작명 규칙을 사용해서 정의한다.
- 스프링 데이터는 서로 다른 종류의 데이터베이스와 함께 사용될 수 있다.
    - 예를 들어, 관계형 데이터베이스인 JPA, 문서형 데이터베이스인 Mongo, 그래프형 데이터베이스인 Neo4j 등이다.

## 스프링 시큐리티

- 스프링은 강력한 보안 프레임워크를 갖고 있다.
- 스프링 시큐리티는 인증(authentication), 허가(authorization), API 보안을 포함하는 폭넓은 범위의 애플리케이션 보안 요구를 다룬다.
- 스프링 시큐리티의 범위가 너무 넓어서 이 책에서는 모두 다루기는 어렵지만, 가장 흔히 사용하는 몇 가지 경우를 4장과 12장에서 알아볼 것이다.

## 스프링 통합과 배치

- 어떤 시점이든 대부분의 애플리케이션은 다른 애플리케이션 또는 같은 애플리케이션의 서로 다른 컴포넌트를 통합(integration)할 필요가 생긴다.
- 이런 요구사항을 해결하기 위해 이미 알려진 몇 가지 애플리케이션 통합 패턴이 있다.
- 스프링 통합과 스프링 배치(Batch)는 스프링 기반 애플리케이션의 이런 패턴 구현을 제공한다.
- 스프링 통합은 데이터가 사용 가능한 즉시 처리되는 실시간 통합을 한다.
- 반면에 스프링 배치에서는 다량의 데이터가 처리되는 시점을 트리거(대개 시간을 기준으로 트리거)가 알려줄 때 데이터가 수집 처리되는 배치 통합을 처리한다.
- 스프링 통합과 배치는 모두 9장에서 알아볼 것이다.

## 스프링 클라우드

- 우리 애플리케이션을 거대한 하나의 단일체로 개발하는 대신 마이크로서비스라는 여러 개의 개별적인 단위들로 합성하는 것이다.
- 스프링을 사용해서 클라우드 애플리케이션을 개발하기 위한 프로젝트들의 모음인 스프링 클라우드를 사용한다.
- 스프링 클라우드에서는 많은 것을 다루므로 이 책에서 모두 알아보는 것은 불가능하다.
- 따라서 이 책에서는 13, 14, 15장에서 스프링 클라우드의 가장 중요한 컴포넌트 중 일부를 알아볼 것이다.